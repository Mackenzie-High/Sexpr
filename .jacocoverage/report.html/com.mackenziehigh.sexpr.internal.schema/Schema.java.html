<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Schema.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Sexpr&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.sexpr.internal.schema</a> &gt; <span class="el_source">Schema.java</span></div><h1>Schema.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2017 Michael Mackenzie High
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.mackenziehigh.sexpr.internal.schema;

import com.mackenziehigh.sexpr.SAtom;
import com.mackenziehigh.sexpr.SList;
import com.mackenziehigh.sexpr.Sexpr;
import com.mackenziehigh.sexpr.annotations.After;
import com.mackenziehigh.sexpr.annotations.Before;
import com.mackenziehigh.sexpr.annotations.Condition;
import com.mackenziehigh.sexpr.annotations.Pass;
import java.lang.reflect.Method;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.SortedMap;
import java.util.Stack;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;

/**
 * An instance of this class is a pattern that describes a symbolic-expression.
 * This class provides the actual implementation of schemas.
 */
public final class Schema
{
    /**
     * This counter is used to create names for anonymous rules.
     */
<span class="fc" id="L53">    private static int counter = 1;</span>

    /**
     * This maintains important state during a match attempt.
     */
<span class="fc" id="L58">    private final class MatchState</span>
    {
        /**
         * This stack is used to store match-nodes.
         * Whenever a successful match occurs, it will be placed onto this stack.
         * Matches will be popped of this stack and made the children of other matches.
         */
<span class="fc" id="L65">        private final Stack&lt;Object&gt; matches = new Stack&lt;&gt;();</span>

        /**
         * This was the last node in the symbolic-expression
         * that was successfully matched.
         */
<span class="fc" id="L71">        private Sexpr lastSuccess = null;</span>

        /**
         * This method retrieves the last node in the symbolic-expression
         * that was successfully matched by a rule in the schema,
         * if such a node exists.
         *
         * &lt;p&gt;
         * The last successful node is useful for debugging purposes.
         * &lt;/p&gt;
         *
         * @return the site of the last successful match, if any.
         */
        public Optional&lt;Sexpr&gt; lastSuccess ()
        {
<span class="fc" id="L86">            return Optional.ofNullable(lastSuccess);</span>
        }

        /**
         * This method is invoked whenever a rule begins a match-attempt.
         *
         * @param node is the node that the rule is attempting to match.
         */
        private void enter (final Sexpr node)
        {
<span class="fc" id="L96">            Objects.requireNonNull(node, &quot;node&quot;);</span>
<span class="fc" id="L97">            matches.push(node);</span>
<span class="fc" id="L98">        }</span>

        /**
         * This method is invoked whenever a rule exits a match-attempt
         * due to the fact that the rule successfully matched.
         *
         * @param rule is the rule invoking this method.
         * @param node is the node that was successfully matched.
         * @return the representation of the successful match.
         */
        private MatchNode exitOnSuccess (final Rule rule,
                                         final Sexpr node)
        {
<span class="fc" id="L111">            lastSuccess = node;</span>

            /**
             * Remove any successful child matches from the stack.
             */
<span class="fc" id="L116">            final LinkedList&lt;MatchNode&gt; children = new LinkedList&lt;&gt;();</span>

<span class="fc bfc" id="L118" title="All 2 branches covered.">            while (matches.peek() != node)</span>
            {
<span class="fc" id="L120">                children.addFirst((MatchNode) matches.pop());</span>
            }

            /**
             * Undo push(node) in enter(node).
             */
<span class="fc" id="L126">            matches.pop();</span>

            /**
             * Create the representation of the successful match.
             */
<span class="fc" id="L131">            final MatchNode match = new MatchNode(rule, node, children);</span>
<span class="fc" id="L132">            matches.push(match);</span>

<span class="fc" id="L134">            return match;</span>
        }

        /**
         * This method is invoked whenever a rule exits a match-attempt
         * due to the fact that the rule failed to match the node.
         *
         * @param rule is the rule invoking this method.
         * @param node is the node that was unsuccessfully matched.
         * @return null always.
         */
        private MatchNode exitOnFailure (final Sexpr node)
        {
            /**
             * Remove any successful child matches from the stack.
             */
<span class="fc bfc" id="L150" title="All 2 branches covered.">            while (matches.peek() != node)</span>
            {
<span class="fc" id="L152">                matches.pop();</span>
            }

            /**
             * Undo push(node) in enter(node).
             */
<span class="fc" id="L158">            matches.pop();</span>

<span class="fc" id="L160">            return null;</span>
        }
    }

    /**
     * An instance of this interface is a constraint on a single node in a symbolic-expression.
     */
<span class="fc" id="L167">    abstract class Rule</span>
    {
        /**
         * The default-name starts with a '#' sign,
         * since '#' starts comments in schemas
         * we can be sure that no rule will (ever)
         * have such a name.
         */
<span class="fc" id="L175">        private final String defaultName = &quot;#&quot; + counter++;</span>

        /**
         * This method determines whether this rule matches the given node.
         *
         * &lt;p&gt;
         * This method must invoke state.enter(node).
         * This method must invoke state.exitOnSuccess(node)
         * or state.exitOnFailure(node) depending on the result.
         * &lt;/p&gt;
         *
         * @param state maintains the state of the overall match attempt.
         * @param node may obey the pattern described by this rule.
         * @return an object representing the successful match of this rule,
         * or null, if this rule does not match the given node.
         */
        public abstract MatchNode match (MatchState state,
                                         Sexpr node);

        /**
         * This method retrieves the name of this rule.
         *
         * @return the name of this rule.
         */
        public String name ()
        {
<span class="fc" id="L201">            return defaultName;</span>
        }
    }

    /**
     * An instance of this interface represents a single element in a sequence-rule.
     */
    interface SequenceElement
    {
        /**
         * This method retrieves the name of the rule that describes the sequence element.
         *
         * @return the name of a rule in the schema.
         */
        public String element ();

        /**
         * This method retrieves the minimum number of times that the element must repeat.
         *
         * @return the lower bound of the sequence-element.
         */
        public int minimum ();

        /**
         * This method retrieves the maximum number of times that the element must repeat.
         *
         * @return the upper bound of the sequence-element.
         */
        public int maximum ();
    }

    /**
     * This function will be invoked on failed match attempts.
     */
<span class="fc" id="L235">    private Consumer&lt;Optional&lt;Sexpr&gt;&gt; failureHandler = x -&gt;</span>
    {
        // Pass.
<span class="fc" id="L238">    };</span>

    /**
     * These are all of the rules that are defined within the schema.
     */
<span class="fc" id="L243">    private final SortedMap&lt;String, Rule&gt; rules = new TreeMap&lt;&gt;();</span>

    /**
     * This supplier supplies the name of the root rule of the schema.
     */
<span class="fc" id="L248">    private String root = &quot;root&quot;;</span>

    /**
     * This map maps the names of user-defined conditions
     * to the definitions of those conditions, if any.
     */
<span class="fc" id="L254">    private final Map&lt;String, Predicate&lt;Sexpr&gt;&gt; conditions = new TreeMap&lt;&gt;();</span>

    /**
     * These are the names of the user-defined translation passes.
     */
<span class="fc" id="L259">    private final List&lt;String&gt; passes = new LinkedList&lt;&gt;();</span>

    /**
     * This map maps the name of a translation pass (P) to a map that maps the name
     * of a rule (R) in the schema to a list of user-defined actions (A1 ... AN)
     * that will be performed for each successful match of (R) during pass (P).
     */
<span class="fc" id="L266">    private final Map&lt;String, Map&lt;String, List&lt;Consumer&lt;Sexpr&gt;&gt;&gt;&gt; beforeActions = new TreeMap&lt;&gt;();</span>

    /**
     * This map maps the name of a translation pass (P) to a map that maps the name
     * of a rule (R) in the schema to a list of user-defined actions (A1 ... AN)
     * that will be performed for each successful match of (R) during pass (P).
     */
<span class="fc" id="L273">    private final Map&lt;String, Map&lt;String, List&lt;Consumer&lt;Sexpr&gt;&gt;&gt;&gt; afterActions = new TreeMap&lt;&gt;();</span>

    /**
     * These are the names of all of the rules that have been used in the schema.
     * This may include undefined rules due to typos, etc, made by the user.
     * Such problems need to be detected and reported.
     */
<span class="fc" id="L280">    private final Set&lt;String&gt; usedRules = new TreeSet&lt;&gt;();</span>

    /**
     * Sole Constructor.
     */
    public Schema ()
<span class="fc" id="L286">    {</span>
        /**
         * Define the predefined rules, whose names always start with a '$' by convention.
         */
<span class="pc" id="L290">        rules.put(&quot;$ANY&quot;, defineRuleByPredicate(x -&gt; true));</span>
<span class="pc bpc" id="L291" title="1 of 4 branches missed.">        rules.put(&quot;$BOOLEAN&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.asAtom().asBoolean().isPresent()));</span>
<span class="pc bnc" id="L292" title="All 4 branches missed.">        rules.put(&quot;$CHAR&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.asAtom().asChar().isPresent()));</span>
<span class="pc bpc" id="L293" title="1 of 4 branches missed.">        rules.put(&quot;$BYTE&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.asAtom().asByte().isPresent()));</span>
<span class="pc bpc" id="L294" title="1 of 4 branches missed.">        rules.put(&quot;$SHORT&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.asAtom().asShort().isPresent()));</span>
<span class="pc bpc" id="L295" title="1 of 4 branches missed.">        rules.put(&quot;$INT&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.asAtom().asInt().isPresent()));</span>
<span class="pc bpc" id="L296" title="1 of 4 branches missed.">        rules.put(&quot;$LONG&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.asAtom().asLong().isPresent()));</span>
<span class="pc bnc" id="L297" title="All 4 branches missed.">        rules.put(&quot;$FLOAT&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.asAtom().asFloat().isPresent()));</span>
<span class="pc bnc" id="L298" title="All 4 branches missed.">        rules.put(&quot;$DOUBLE&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.asAtom().asDouble().isPresent()));</span>
<span class="pc bnc" id="L299" title="All 4 branches missed.">        rules.put(&quot;$CLASS&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.asAtom().asClass().isPresent()));</span>
<span class="pc" id="L300">        rules.put(&quot;$ATOM&quot;, defineRuleByPredicate(x -&gt; x.isAtom()));</span>
<span class="pc" id="L301">        rules.put(&quot;$LIST&quot;, defineRuleByPredicate(x -&gt; x.isList()));</span>
<span class="fc" id="L302">    }</span>

    /**
     * This method sets the failure-handler.
     *
     * @param handler is the new handler.
     */
    public void setFailureHandler (final Consumer&lt;Optional&lt;Sexpr&gt;&gt; handler)
    {
<span class="fc" id="L311">        Objects.requireNonNull(handler, &quot;handler&quot;);</span>
<span class="fc" id="L312">        failureHandler = handler;</span>
<span class="fc" id="L313">    }</span>

    /**
     * This method causes a rule to be added to this schema.
     *
     * @param rule is the rule to add.
     * @return the rule.
     */
    private Rule define (final Rule rule)
    {
<span class="fc" id="L323">        Objects.requireNonNull(rule, &quot;rule&quot;);</span>
<span class="fc" id="L324">        rules.put(rule.name(), rule);</span>
<span class="fc" id="L325">        return rule;</span>
    }

    /**
     * Use this method to specify the root rule of this schema.
     *
     * @param root is the name of the root rule.
     */
    public void defineRoot (final String root)
    {
<span class="fc" id="L335">        Objects.requireNonNull(root, &quot;root&quot;);</span>
<span class="fc" id="L336">        usedRules.add(root);</span>
<span class="fc" id="L337">        this.root = root;</span>
<span class="fc" id="L338">    }</span>

    /**
     * This method defines a condition that can be referenced by a 'require' rule.
     *
     * @param name is the name of the user-defined condition.
     * @param condition is the user-defined condition itself.
     */
    public void defineCondition (final String name,
                                 final Predicate&lt;Sexpr&gt; condition)
    {
<span class="fc" id="L349">        Objects.requireNonNull(name, &quot;name&quot;);</span>
<span class="fc" id="L350">        Objects.requireNonNull(condition, &quot;condition&quot;);</span>
<span class="fc" id="L351">        conditions.put(name, condition);</span>
<span class="fc" id="L352">    }</span>

    /**
     * Use this method to create a rule that provides a name for another rule.
     *
     * @param name is the name of the new rule.
     * @param body is the name of the referenced (usually anonymous) rule.
     * @return the new rule.
     */
    final Rule defineNamedRule (final String name,
                                final String body)
    {
<span class="fc" id="L364">        Objects.requireNonNull(name, &quot;name&quot;);</span>
<span class="fc" id="L365">        Objects.requireNonNull(body, &quot;body&quot;);</span>

<span class="fc bfc" id="L367" title="All 2 branches covered.">        if (rules.containsKey(name))</span>
        {
<span class="fc" id="L369">            throw new IllegalStateException(&quot;Duplicate Rule: &quot; + name);</span>
        }

<span class="fc" id="L372">        usedRules.add(name);</span>
<span class="fc" id="L373">        usedRules.add(body);</span>

<span class="fc" id="L375">        final Rule rule = new Rule()</span>
<span class="fc" id="L376">        {</span>
            @Override
            public String name ()
            {
<span class="fc" id="L380">                return name;</span>
            }

            @Override
            public MatchNode match (final MatchState state,
                                    final Sexpr node)
            {
<span class="fc" id="L387">                state.enter(node);</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">                final boolean answer = rules.get(body).match(state, node) != null;</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">                return answer ? state.exitOnSuccess(this, node) : state.exitOnFailure(node);</span>
            }
        };

<span class="fc" id="L393">        return define(rule);</span>
    }

    /**
     * Use this method to create a rule that is a lazy reference to another rule.
     *
     * @param name is the name of the new rule.
     * @return the new rule.
     */
    final Rule defineReference (final String name)
    {
<span class="fc" id="L404">        Objects.requireNonNull(name, &quot;name&quot;);</span>

<span class="fc" id="L406">        usedRules.add(name);</span>

        /**
         * This type of rule is a special-case.
         * Do *not* invoke enter(*), exitOnSuccess(*), or exitOnFailure(*),
         * because that would break how action execution works.
         */
<span class="fc" id="L413">        final Rule rule = new Rule()</span>
<span class="fc" id="L414">        {</span>
            @Override
            public MatchNode match (final MatchState state,
                                    final Sexpr node)
            {
<span class="fc" id="L419">                return rules.get(name).match(state, node);</span>
            }
        };

<span class="fc" id="L423">        return define(rule);</span>
    }

    /**
     * Use this method to define a rule that will only successfully match
     * a node when a series of operand rules always match the node.
     *
     * @param operands must all match the same node in order for the new rule to match.
     * @return the new rule.
     */
    final Rule defineAndRule (final List&lt;String&gt; operands)
    {
<span class="fc" id="L435">        Objects.requireNonNull(operands, &quot;operands&quot;);</span>
<span class="fc" id="L436">        operands.forEach(operand -&gt; Objects.requireNonNull(operand, &quot;operand&quot;));</span>

<span class="fc" id="L438">        usedRules.addAll(operands);</span>

<span class="fc" id="L440">        final Rule rule = new Rule()</span>
<span class="fc" id="L441">        {</span>
            @Override
            public MatchNode match (final MatchState state,
                                    final Sexpr node)
            {
<span class="fc" id="L446">                state.enter(node);</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">                final boolean answer = operands.stream().map(name -&gt; rules.get(name)).allMatch(rule -&gt; rule.match(state, node) != null);</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">                return answer ? state.exitOnSuccess(this, node) : state.exitOnFailure(node);</span>
            }
        };

<span class="fc" id="L452">        return define(rule);</span>
    }

    /**
     * Use this method to define a rule that will successfully match a node
     * when the first of a series of operand rules matches the node.
     *
     * @param operands are the options that may match the node.
     * @return the new rule.
     */
    final Rule defineOrRule (final List&lt;String&gt; operands)
    {
<span class="fc" id="L464">        Objects.requireNonNull(operands, &quot;operands&quot;);</span>
<span class="fc" id="L465">        operands.forEach(operand -&gt; Objects.requireNonNull(operand, &quot;operand&quot;));</span>

<span class="fc" id="L467">        usedRules.addAll(operands);</span>

<span class="fc" id="L469">        final Rule rule = new Rule()</span>
<span class="fc" id="L470">        {</span>
            @Override
            public MatchNode match (final MatchState state,
                                    final Sexpr node)
            {
<span class="fc" id="L475">                state.enter(node);</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">                final boolean answer = operands.stream().map(name -&gt; rules.get(name)).anyMatch(rule -&gt; rule.match(state, node) != null);</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">                return answer ? state.exitOnSuccess(this, node) : state.exitOnFailure(node);</span>
            }
        };

<span class="fc" id="L481">        return define(rule);</span>
    }

    /**
     * Use this method to define a rule that will only successfully
     * match a node when a given operand rule fails to match.
     *
     * @param operand the rule that is negated by the new rule.
     * @return the new rule.
     */
    final Rule defineNotRule (final String operand)
    {
<span class="fc" id="L493">        Objects.requireNonNull(operand, &quot;operand&quot;);</span>

<span class="fc" id="L495">        usedRules.add(operand);</span>

<span class="fc" id="L497">        final Rule rule = new Rule()</span>
<span class="fc" id="L498">        {</span>
            @Override
            public MatchNode match (final MatchState state,
                                    final Sexpr node)
            {
<span class="fc" id="L503">                state.enter(node);</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">                final boolean answer = rules.get(operand).match(state, node) == null;</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">                return answer ? state.exitOnSuccess(this, node) : state.exitOnFailure(node);</span>
            }
        };

<span class="fc" id="L509">        return define(rule);</span>
    }

    /**
     * Use this method to define a rule that will only successfully
     * match a symbolic-list that obeys a proscribed sequence.
     *
     * @param operands describe the elements in the sequence.
     * @return the new rule.
     */
    final Rule defineSequenceRule (final List&lt;? extends SequenceElement&gt; operands)
    {
<span class="fc" id="L521">        Objects.requireNonNull(operands, &quot;operands&quot;);</span>
<span class="fc" id="L522">        operands.forEach(operand -&gt; Objects.requireNonNull(operand, &quot;operand&quot;));</span>

<span class="fc bfc" id="L524" title="All 2 branches covered.">        for (SequenceElement operand : operands)</span>
        {
<span class="fc bfc" id="L526" title="All 2 branches covered.">            if (operand.maximum() &lt; operand.minimum())</span>
            {
<span class="fc" id="L528">                final String message = String.format(&quot;Invalid Range: { %d, %d }&quot;,</span>
<span class="fc" id="L529">                                                     operand.minimum(),</span>
<span class="fc" id="L530">                                                     operand.maximum());</span>
<span class="fc" id="L531">                throw new IllegalStateException(message);</span>
            }
<span class="fc" id="L533">        }</span>

<span class="fc" id="L535">        operands.forEach(x -&gt; usedRules.add(x.element()));</span>

<span class="fc" id="L537">        final Rule rule = new Rule()</span>
<span class="fc" id="L538">        {</span>
            @Override
            public MatchNode match (final MatchState state,
                                    final Sexpr node)
            {
<span class="fc" id="L543">                return sequenceMatch(this, operands, state, node);</span>
            }
        };

<span class="fc" id="L547">        return define(rule);</span>
    }

    private MatchNode sequenceMatch (final Rule rule,
                                     final List&lt;? extends SequenceElement&gt; operands,
                                     final MatchState state,
                                     final Sexpr node)
    {
<span class="fc" id="L555">        Objects.requireNonNull(rule, &quot;rule&quot;);</span>
<span class="fc" id="L556">        Objects.requireNonNull(operands, &quot;operands&quot;);</span>
<span class="fc" id="L557">        operands.forEach(operand -&gt; Objects.requireNonNull(operand, &quot;operand&quot;));</span>
<span class="fc" id="L558">        Objects.requireNonNull(state, &quot;state&quot;);</span>
<span class="fc" id="L559">        Objects.requireNonNull(node, &quot;node&quot;);</span>

<span class="fc" id="L561">        state.enter(node);</span>

<span class="pc bpc" id="L563" title="1 of 2 branches missed.">        if (node.isList() == false)</span>
        {
<span class="nc" id="L565">            return state.exitOnFailure(node);</span>
        }

<span class="fc" id="L568">        final Deque&lt;Sexpr&gt; nodes = new ArrayDeque&lt;&gt;(node.asList());</span>

<span class="fc bfc" id="L570" title="All 2 branches covered.">seq:    for (SequenceElement operand : operands)</span>
        {
            int i;

            /**
             * The operand rule must match at least the minimum number of times.
             */
<span class="fc bfc" id="L577" title="All 2 branches covered.">            for (i = 0; i &lt; operand.minimum(); i++)</span>
            {
                /**
                 * If no more nodes are in the list, then the rule has failed to match,
                 * because the minium match count was not reached for this operand rule.
                 */
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">                if (nodes.isEmpty())</span>
                {
<span class="nc" id="L585">                    return state.exitOnFailure(node);</span>
                }

<span class="fc" id="L588">                final Sexpr next = nodes.peek();</span>
<span class="fc" id="L589">                final MatchNode match = rules.get(operand.element()).match(state, next);</span>

<span class="fc bfc" id="L591" title="All 2 branches covered.">                if (match == null)</span>
                {
<span class="fc" id="L593">                    return state.exitOnFailure(node);</span>
                }
                else
                {
<span class="fc" id="L597">                    nodes.pop();</span>
                }
            }

            /**
             * The operand rule can continue to match until the maximum is reached.
             */
<span class="fc bfc" id="L604" title="All 2 branches covered.">            for (i = i + 0; i &lt; operand.maximum(); i++)</span>
            {
                /**
                 * If no more nodes are in the list, then goto the next operand rule,
                 * because the tail rules may be require to match more than zero times.
                 * In that case, the overall sequence rule has failed,
                 * even though the current operand rule succeeded.
                 */
<span class="fc bfc" id="L612" title="All 2 branches covered.">                if (nodes.isEmpty())</span>
                {
<span class="fc" id="L614">                    continue seq;</span>
                }

<span class="fc" id="L617">                final Sexpr next = nodes.peek();</span>
<span class="fc" id="L618">                final MatchNode match = rules.get(operand.element()).match(state, next);</span>

<span class="fc bfc" id="L620" title="All 2 branches covered.">                if (match == null)</span>
                {
<span class="fc" id="L622">                    continue seq; // Go to the next operand rule.</span>
                }
                else
                {
<span class="fc" id="L626">                    nodes.pop();</span>
                }
            }
<span class="fc" id="L629">        }</span>

        /**
         * If there are still more nodes in the list,
         * then the sequence-rule only described the prefix of the list,
         * which we do not consider to be a true match of the list.
         */
<span class="fc bfc" id="L636" title="All 2 branches covered.">        if (nodes.isEmpty() == false)</span>
        {
<span class="fc" id="L638">            return state.exitOnFailure(node);</span>
        }

<span class="fc" id="L641">        return state.exitOnSuccess(rule, node);</span>
    }

    /**
     * Use this method to define a rule that will only successfully match
     * a symbolic-atom whose content() matches a given regular-expression.
     *
     * @param pattern is the given symbolic-expression.
     * @return the new rule.
     */
    final Rule defineRegexRule (final String pattern)
    {
<span class="fc" id="L653">        Objects.requireNonNull(pattern, &quot;pattern&quot;);</span>

<span class="pc bpc" id="L655" title="1 of 4 branches missed.">        return defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.asAtom().content().matches(pattern));</span>
    }

    /**
     * Use this method to define a rule that will only successfully
     * match a symbolic-atom whose content() equals the given value.
     *
     * @param value is the value that must be the content() of the node.
     * @return the new rule.
     */
    final Rule defineConstantRule (final String value)
    {
<span class="fc" id="L667">        Objects.requireNonNull(value, &quot;value&quot;);</span>

<span class="pc bpc" id="L669" title="2 of 4 branches missed.">        return defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.asAtom().content().equals(value));</span>
    }

    /**
     * Use this method to define a new rule that will only successfully
     * match a node when a user-defined predicate matches the node.
     *
     * @param name is the name of the user-defined requirement.
     * @return the new rule.
     */
    final Rule definePredicateRule (final String name)
    {
<span class="fc" id="L681">        Objects.requireNonNull(name, &quot;name&quot;);</span>

<span class="fc" id="L683">        return defineRuleByPredicate(x -&gt; Optional.ofNullable(conditions.get(name)).get().test(x));</span>
    }

    /**
     * Use this method to define a new rule that will only successfully
     * match a node when a given predicate matches the node.
     *
     * @param condition is the predicate.
     * @return the new rule.
     */
    private Rule defineRuleByPredicate (final Predicate&lt;Sexpr&gt; condition)
    {
<span class="fc" id="L695">        Objects.requireNonNull(condition, &quot;condition&quot;);</span>

<span class="fc" id="L697">        final Rule rule = new Rule()</span>
<span class="fc" id="L698">        {</span>
            @Override
            public MatchNode match (final MatchState state,
                                    final Sexpr node)
            {
<span class="fc" id="L703">                state.enter(node);</span>
<span class="fc" id="L704">                final boolean answer = condition.test(node);</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">                return answer ? state.exitOnSuccess(this, node) : state.exitOnFailure(node);</span>
            }
        };

<span class="fc" id="L709">        return define(rule);</span>
    }

    /**
     * Use this method to define another compiler pass.
     *
     * &lt;p&gt;
     * The order in which this method is invoked will
     * define the order of compiler passes relative
     * to one another.
     * &lt;/p&gt;
     *
     * @param name is the name of the new compiler pass.
     */
    public void definePass (final String name)
    {
<span class="fc" id="L725">        Objects.requireNonNull(name, &quot;name&quot;);</span>
<span class="fc" id="L726">        passes.add(name);</span>
<span class="fc" id="L727">    }</span>

    public void defineBeforeAction (final String pass,
                                    final String rule,
                                    final Consumer&lt;Sexpr&gt; action)
    {
<span class="fc" id="L733">        Objects.requireNonNull(pass, &quot;pass&quot;);</span>
<span class="fc" id="L734">        Objects.requireNonNull(rule, &quot;rule&quot;);</span>
<span class="fc" id="L735">        Objects.requireNonNull(action, &quot;action&quot;);</span>

<span class="fc bfc" id="L737" title="All 2 branches covered.">        if (beforeActions.containsKey(pass) == false)</span>
        {
<span class="fc" id="L739">            beforeActions.put(pass, new TreeMap&lt;&gt;());</span>
        }

<span class="pc bpc" id="L742" title="1 of 2 branches missed.">        if (beforeActions.get(pass).containsKey(rule) == false)</span>
        {
<span class="fc" id="L744">            beforeActions.get(pass).put(rule, new LinkedList&lt;&gt;());</span>
        }

<span class="fc" id="L747">        beforeActions.get(pass).get(rule).add(action);</span>
<span class="fc" id="L748">    }</span>

    public void defineAfterAction (final String pass,
                                   final String rule,
                                   final Consumer&lt;Sexpr&gt; action)
    {
<span class="fc" id="L754">        Objects.requireNonNull(pass, &quot;pass&quot;);</span>
<span class="fc" id="L755">        Objects.requireNonNull(rule, &quot;rule&quot;);</span>
<span class="fc" id="L756">        Objects.requireNonNull(action, &quot;action&quot;);</span>

<span class="fc bfc" id="L758" title="All 2 branches covered.">        if (afterActions.containsKey(pass) == false)</span>
        {
<span class="fc" id="L760">            afterActions.put(pass, new TreeMap&lt;&gt;());</span>
        }

<span class="pc bpc" id="L763" title="1 of 2 branches missed.">        if (afterActions.get(pass).containsKey(rule) == false)</span>
        {
<span class="fc" id="L765">            afterActions.get(pass).put(rule, new LinkedList&lt;&gt;());</span>
        }

<span class="fc" id="L768">        afterActions.get(pass).get(rule).add(action);</span>
<span class="fc" id="L769">    }</span>

    /**
     * Given an object containing properly annotated methods,
     * define the conditions and actions defined therein.
     *
     * @param object contains condition and action definitions.
     */
    public void defineViaReflection (final Object object)
    {
<span class="fc" id="L779">        final Optional&lt;String&gt; defaultPass = getDefaultPass(object);</span>

<span class="fc bfc" id="L781" title="All 2 branches covered.">        for (Method method : object.getClass().getMethods())</span>
        {
<span class="fc bfc" id="L783" title="All 2 branches covered.">            if (method.isAnnotationPresent(Condition.class))</span>
            {
<span class="fc" id="L785">                defineConditionViaReflection(object, method);</span>
            }

<span class="fc bfc" id="L788" title="All 2 branches covered.">            if (method.isAnnotationPresent(Before.class))</span>
            {
<span class="fc" id="L790">                defineBeforeActionByReflection(defaultPass, object, method);</span>
            }

<span class="fc bfc" id="L793" title="All 2 branches covered.">            if (method.isAnnotationPresent(After.class))</span>
            {
<span class="fc" id="L795">                defineAfterActionByReflection(defaultPass, object, method);</span>
            }
        }
<span class="fc" id="L798">    }</span>

    private Optional&lt;String&gt; getDefaultPass (final Object object)
    {
<span class="fc bfc" id="L802" title="All 2 branches covered.">        if (object.getClass().isAnnotationPresent(Pass.class))</span>
        {
<span class="fc" id="L804">            final String name = object.getClass().getAnnotation(Pass.class).value();</span>
<span class="fc" id="L805">            return Optional.of(name);</span>
        }
        else
        {
<span class="fc" id="L809">            return Optional.empty();</span>
        }
    }

    private String getPass (final Optional&lt;String&gt; defaultPass,
                            final Method method)
    {
<span class="fc bfc" id="L816" title="All 2 branches covered.">        if (method.isAnnotationPresent(Pass.class))</span>
        {
<span class="fc" id="L818">            final String name = method.getAnnotation(Pass.class).value();</span>
<span class="fc" id="L819">            return name;</span>
        }
<span class="pc bpc" id="L821" title="1 of 2 branches missed.">        else if (defaultPass.isPresent())</span>
        {
<span class="fc" id="L823">            return defaultPass.get();</span>
        }
        else
        {
<span class="nc" id="L827">            throw new IllegalArgumentException(&quot;No translation pass was specified on either the class or method.&quot;);</span>
        }
    }

    private void defineConditionViaReflection (final Object object,
                                               final Method method)
    {
        /**
         * Obtain the user-defined name of the condition.
         */
<span class="fc" id="L837">        final String name = method.getAnnotation(Condition.class).value();</span>

        /**
         * The method cannot throw any checked exceptions.
         */
<span class="fc bfc" id="L842" title="All 2 branches covered.">        if (method.getExceptionTypes().length != 0)</span>
        {
<span class="fc" id="L844">            final String message = String.format(&quot;Do *not* throw checked exceptions in (%s).&quot;, method.toString());</span>
<span class="fc" id="L845">            throw new IllegalArgumentException(message);</span>
        }

        /**
         * The return-type of the method must be boolean.
         */
<span class="fc bfc" id="L851" title="All 2 branches covered.">        if (method.getReturnType().equals(boolean.class) == false)</span>
        {
<span class="fc" id="L853">            final String message = String.format(&quot;You must return boolean from (%s), not %s.&quot;,</span>
<span class="fc" id="L854">                                                 method.toString(),</span>
<span class="fc" id="L855">                                                 method.getReturnType().getName());</span>
<span class="fc" id="L856">            throw new IllegalArgumentException(message);</span>
        }

        /**
         * The method must take exactly one argument,
         * which must be a symbolic-expression.
         */
<span class="fc bfc" id="L863" title="All 2 branches covered.">        if (method.getParameterCount() != 1)</span>
        {
<span class="fc" id="L865">            final String message = String.format(&quot;Method (%s) must take exactly one parameter.&quot;, method.toString());</span>
<span class="fc" id="L866">            throw new IllegalArgumentException(message);</span>
        }
<span class="fc bfc" id="L868" title="All 2 branches covered.">        else if (method.getParameterTypes()[0].equals(Sexpr.class))</span>
        {
<span class="fc" id="L870">            final Function&lt;Sexpr, Object&gt; invocation = createInvocation(object, method);</span>
<span class="fc" id="L871">            final Predicate&lt;Sexpr&gt; condition = x -&gt; (Boolean) invocation.apply(x);</span>
<span class="fc" id="L872">            defineCondition(name, condition);</span>
<span class="fc" id="L873">        }</span>
<span class="fc bfc" id="L874" title="All 2 branches covered.">        else if (method.getParameterTypes()[0].equals(SAtom.class))</span>
        {
<span class="fc" id="L876">            final Function&lt;SAtom, Object&gt; invocation = createInvocation(object, method);</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">            final Predicate&lt;Sexpr&gt; condition = x -&gt; x.isAtom() ? (Boolean) invocation.apply(x.asAtom()) : false;</span>
<span class="fc" id="L878">            defineCondition(name, condition);</span>
<span class="fc" id="L879">        }</span>
<span class="fc bfc" id="L880" title="All 2 branches covered.">        else if (method.getParameterTypes()[0].equals(SList.class))</span>
        {
<span class="fc" id="L882">            final Function&lt;SList, Object&gt; invocation = createInvocation(object, method);</span>
<span class="fc bfc" id="L883" title="All 2 branches covered.">            final Predicate&lt;Sexpr&gt; condition = x -&gt; x.isList() ? (Boolean) invocation.apply(x.asList()) : false;</span>
<span class="fc" id="L884">            defineCondition(name, condition);</span>
<span class="fc" id="L885">        }</span>
        else
        {
<span class="fc" id="L888">            final String message = String.format(&quot;Method (%s) must take a %s|%s|%s as its only parameter.&quot;,</span>
<span class="fc" id="L889">                                                 method.toString(),</span>
<span class="fc" id="L890">                                                 Sexpr.class.getName(),</span>
<span class="fc" id="L891">                                                 SAtom.class.getName(),</span>
<span class="fc" id="L892">                                                 SList.class.getName());</span>
<span class="fc" id="L893">            throw new IllegalArgumentException(message);</span>
        }
<span class="fc" id="L895">    }</span>

    private void defineBeforeActionByReflection (final Optional&lt;String&gt; defaultPass,
                                                 final Object object,
                                                 final Method method)
    {
        /**
         * Obtain the name of the translation pass that this action applies to.
         */
<span class="fc" id="L904">        final String pass = getPass(defaultPass, method);</span>

        /**
         * Obtain the user-defined name of the rule that this action applies to.
         */
<span class="fc" id="L909">        final String rule = method.getAnnotation(Before.class).value();</span>

        /**
         * The method cannot throw any checked exceptions.
         */
<span class="fc bfc" id="L914" title="All 2 branches covered.">        if (method.getExceptionTypes().length != 0)</span>
        {
<span class="fc" id="L916">            final String message = String.format(&quot;Do *not* throw checked exceptions in (%s).&quot;, method.toString());</span>
<span class="fc" id="L917">            throw new IllegalArgumentException(message);</span>
        }

        /**
         * The return-type of the method must be void.
         */
<span class="fc bfc" id="L923" title="All 2 branches covered.">        if (method.getReturnType().equals(void.class) == false)</span>
        {
<span class="fc" id="L925">            final String message = String.format(&quot;You must return boolean from (%s), not %s.&quot;,</span>
<span class="fc" id="L926">                                                 method.toString(),</span>
<span class="fc" id="L927">                                                 method.getReturnType().getName());</span>
<span class="fc" id="L928">            throw new IllegalArgumentException(message);</span>
        }

        /**
         * The method must take exactly one argument,
         * which must be a symbolic-expression.
         */
<span class="fc bfc" id="L935" title="All 2 branches covered.">        if (method.getParameterCount() != 1)</span>
        {
<span class="fc" id="L937">            final String message = String.format(&quot;Method (%s) must take exactly one parameter.&quot;, method.toString());</span>
<span class="fc" id="L938">            throw new IllegalArgumentException(message);</span>
        }
<span class="fc bfc" id="L940" title="All 2 branches covered.">        else if (method.getParameterTypes()[0].equals(Sexpr.class))</span>
        {
<span class="fc" id="L942">            final Function&lt;Sexpr, Object&gt; invocation = createInvocation(object, method);</span>
<span class="fc" id="L943">            final Consumer&lt;Sexpr&gt; action = x -&gt; invocation.apply(x);</span>
<span class="fc" id="L944">            defineBeforeAction(pass, rule, action);</span>
<span class="fc" id="L945">        }</span>
<span class="fc bfc" id="L946" title="All 2 branches covered.">        else if (method.getParameterTypes()[0].equals(SAtom.class))</span>
        {
<span class="fc" id="L948">            final Function&lt;SAtom, Object&gt; invocation = createInvocation(object, method);</span>
<span class="fc" id="L949">            final Consumer&lt;Sexpr&gt; action = x -&gt; invocation.apply(x.asAtom());</span>
<span class="fc" id="L950">            defineBeforeAction(pass, rule, action);</span>
<span class="fc" id="L951">        }</span>
<span class="fc bfc" id="L952" title="All 2 branches covered.">        else if (method.getParameterTypes()[0].equals(SList.class))</span>
        {
<span class="fc" id="L954">            final Function&lt;SList, Object&gt; invocation = createInvocation(object, method);</span>
<span class="fc" id="L955">            final Consumer&lt;Sexpr&gt; action = x -&gt; invocation.apply(x.asList());</span>
<span class="fc" id="L956">            defineBeforeAction(pass, rule, action);</span>
<span class="fc" id="L957">        }</span>
        else
        {
<span class="fc" id="L960">            final String message = String.format(&quot;Method (%s) must take a %s|%s|%s as its only parameter.&quot;,</span>
<span class="fc" id="L961">                                                 method.toString(),</span>
<span class="fc" id="L962">                                                 Sexpr.class.getName(),</span>
<span class="fc" id="L963">                                                 SAtom.class.getName(),</span>
<span class="fc" id="L964">                                                 SList.class.getName());</span>
<span class="fc" id="L965">            throw new IllegalArgumentException(message);</span>
        }
<span class="fc" id="L967">    }</span>

    private void defineAfterActionByReflection (final Optional&lt;String&gt; defaultPass,
                                                final Object object,
                                                final Method method)
    {
        /**
         * Obtain the name of the translation pass that this action applies to.
         */
<span class="fc" id="L976">        final String pass = getPass(defaultPass, method);</span>

        /**
         * Obtain the user-defined name of the rule that this action applies to.
         */
<span class="fc" id="L981">        final String rule = method.getAnnotation(After.class).value();</span>

        /**
         * The method cannot throw any checked exceptions.
         */
<span class="fc bfc" id="L986" title="All 2 branches covered.">        if (method.getExceptionTypes().length != 0)</span>
        {
<span class="fc" id="L988">            final String message = String.format(&quot;Do *not* throw checked exceptions in (%s).&quot;, method.toString());</span>
<span class="fc" id="L989">            throw new IllegalArgumentException(message);</span>
        }

        /**
         * The return-type of the method must be void.
         */
<span class="fc bfc" id="L995" title="All 2 branches covered.">        if (method.getReturnType().equals(void.class) == false)</span>
        {
<span class="fc" id="L997">            final String message = String.format(&quot;You must return boolean from (%s), not %s.&quot;,</span>
<span class="fc" id="L998">                                                 method.toString(),</span>
<span class="fc" id="L999">                                                 method.getReturnType().getName());</span>
<span class="fc" id="L1000">            throw new IllegalArgumentException(message);</span>
        }

        /**
         * The method must take exactly one argument,
         * which must be a symbolic-expression.
         */
<span class="fc bfc" id="L1007" title="All 2 branches covered.">        if (method.getParameterCount() != 1)</span>
        {
<span class="fc" id="L1009">            final String message = String.format(&quot;Method (%s) must take exactly one parameter.&quot;, method.toString());</span>
<span class="fc" id="L1010">            throw new IllegalArgumentException(message);</span>
        }
<span class="fc bfc" id="L1012" title="All 2 branches covered.">        else if (method.getParameterTypes()[0].equals(Sexpr.class))</span>
        {
<span class="fc" id="L1014">            final Function&lt;Sexpr, Object&gt; invocation = createInvocation(object, method);</span>
<span class="fc" id="L1015">            final Consumer&lt;Sexpr&gt; action = x -&gt; invocation.apply(x);</span>
<span class="fc" id="L1016">            defineAfterAction(pass, rule, action);</span>
<span class="fc" id="L1017">        }</span>
<span class="fc bfc" id="L1018" title="All 2 branches covered.">        else if (method.getParameterTypes()[0].equals(SAtom.class))</span>
        {
<span class="fc" id="L1020">            final Function&lt;SAtom, Object&gt; invocation = createInvocation(object, method);</span>
<span class="fc" id="L1021">            final Consumer&lt;Sexpr&gt; action = x -&gt; invocation.apply(x.asAtom());</span>
<span class="fc" id="L1022">            defineAfterAction(pass, rule, action);</span>
<span class="fc" id="L1023">        }</span>
<span class="fc bfc" id="L1024" title="All 2 branches covered.">        else if (method.getParameterTypes()[0].equals(SList.class))</span>
        {
<span class="fc" id="L1026">            final Function&lt;SList, Object&gt; invocation = createInvocation(object, method);</span>
<span class="fc" id="L1027">            final Consumer&lt;Sexpr&gt; action = x -&gt; invocation.apply(x.asList());</span>
<span class="fc" id="L1028">            defineAfterAction(pass, rule, action);</span>
<span class="fc" id="L1029">        }</span>
        else
        {
<span class="fc" id="L1032">            final String message = String.format(&quot;Method (%s) must take a %s|%s|%s as its only parameter.&quot;,</span>
<span class="fc" id="L1033">                                                 method.toString(),</span>
<span class="fc" id="L1034">                                                 Sexpr.class.getName(),</span>
<span class="fc" id="L1035">                                                 SAtom.class.getName(),</span>
<span class="fc" id="L1036">                                                 SList.class.getName());</span>
<span class="fc" id="L1037">            throw new IllegalArgumentException(message);</span>
        }
<span class="fc" id="L1039">    }</span>

    private &lt;T&gt; Function&lt;T, Object&gt; createInvocation (final Object object,
                                                      final Method method)
    {
<span class="fc" id="L1044">        final Function&lt;T, Object&gt; function = x -&gt;</span>
        {
            try
            {
<span class="fc" id="L1048">                method.setAccessible(true);</span>
<span class="fc" id="L1049">                return method.invoke(object, x);</span>
            }
<span class="nc" id="L1051">            catch (Throwable ex)</span>
            {
<span class="nc" id="L1053">                throw new RuntimeException(x.toString(), ex);</span>
            }
        };

<span class="fc" id="L1057">        return function;</span>
    }

    /**
     * This method performs a match-attempt.
     *
     * @param tree is the symbolic-expression that this schema may match.
     * @return true, iff the match was successful.
     */
    public boolean match (final Sexpr tree)
    {
<span class="fc" id="L1068">        Objects.requireNonNull(tree, &quot;tree&quot;);</span>

        /**
         * Verify that this schema is well-defined.
         */
<span class="fc" id="L1073">        validate();</span>

        /**
         * Perform the match attempt.
         */
<span class="fc" id="L1078">        final MatchState state = new MatchState();</span>
<span class="fc" id="L1079">        final Rule rootRule = rules.get(root);</span>
<span class="fc" id="L1080">        final MatchNode match = rootRule.match(state, tree);</span>

        /**
         * If the match-attempt failed, then report the failure;
         * otherwise, execute the user-defined passes and actions.
         */
<span class="fc bfc" id="L1086" title="All 2 branches covered.">        if (match == null)</span>
        {
<span class="fc" id="L1088">            failureHandler.accept(state.lastSuccess());</span>
<span class="fc" id="L1089">            return false;</span>
        }
        else
        {
<span class="fc" id="L1093">            executeActions(match);</span>
<span class="fc" id="L1094">            return true;</span>
        }
    }

    public void validate ()
    {
<span class="fc" id="L1100">        requireRoot();</span>
<span class="fc" id="L1101">        checkForUndefinedRules();</span>
<span class="fc" id="L1102">        checkForUndeclaredPasses();</span>
<span class="fc" id="L1103">    }</span>

    private void requireRoot ()
    {
<span class="pc bpc" id="L1107" title="1 of 2 branches missed.">        if (rules.containsKey(root) == false)</span>
        {
<span class="nc" id="L1109">            throw new IllegalStateException(&quot;No Root Rule&quot;);</span>
        }
<span class="fc" id="L1111">    }</span>

    /**
     * This method reports any rules that are used, but not defined in the schema.
     */
    private void checkForUndefinedRules ()
    {
<span class="fc" id="L1118">        final Set&lt;String&gt; definedRules = rules.keySet();</span>
<span class="fc" id="L1119">        final Set&lt;String&gt; temp = new HashSet&lt;&gt;(usedRules);</span>
<span class="fc" id="L1120">        temp.removeAll(definedRules);</span>
<span class="fc" id="L1121">        final List&lt;String&gt; undefinedRules = new ArrayList&lt;&gt;(temp);</span>

<span class="pc bpc" id="L1123" title="1 of 2 branches missed.">        if (undefinedRules.isEmpty() == false)</span>
        {
<span class="nc" id="L1125">            final String names = SList.copyOf(undefinedRules.stream().map(name -&gt; SAtom.fromString(name))).toString();</span>
<span class="nc" id="L1126">            final String message = &quot;Undefined Rules Detected: &quot; + names;</span>
<span class="nc" id="L1127">            throw new IllegalStateException(message);</span>
        }
<span class="fc" id="L1129">    }</span>

    private void checkForUndeclaredPasses ()
    {
        /**
         * Check for before-actions that are not apart of a declared pass.
         */
<span class="fc bfc" id="L1136" title="All 2 branches covered.">        for (String pass : beforeActions.keySet())</span>
        {
<span class="fc bfc" id="L1138" title="All 2 branches covered.">            if (passes.contains(pass) == false)</span>
            {
<span class="fc" id="L1140">                throw new IllegalStateException(String.format(&quot;Undeclared Pass: %s&quot;, pass));</span>
            }
<span class="fc" id="L1142">        }</span>

        /**
         * Check for after-actions that are not apart of a declared pass.
         */
<span class="fc bfc" id="L1147" title="All 2 branches covered.">        for (String pass : afterActions.keySet())</span>
        {
<span class="fc bfc" id="L1149" title="All 2 branches covered.">            if (passes.contains(pass) == false)</span>
            {
<span class="fc" id="L1151">                throw new IllegalStateException(String.format(&quot;Undeclared Pass: %s&quot;, pass));</span>
            }
<span class="fc" id="L1153">        }</span>
<span class="fc" id="L1154">    }</span>

    /**
     * On successful matches, this method transverses the match-tree
     * in multiple &quot;translation passes&quot; executing user-defined actions.
     *
     * @param tree describes a successful match attempt.
     */
    private void executeActions (final MatchNode tree)
    {
<span class="fc" id="L1164">        passes.forEach(pass -&gt; executeActions(pass, tree));</span>
<span class="fc" id="L1165">    }</span>

    private void executeActions (final String pass,
                                 final MatchNode node)
    {
<span class="fc bfc" id="L1170" title="All 4 branches covered.">        if (beforeActions.containsKey(pass) &amp;&amp; beforeActions.get(pass).containsKey(node.rule().name()))</span>
        {
<span class="fc" id="L1172">            final List&lt;Consumer&lt;Sexpr&gt;&gt; actions = beforeActions.get(pass).get(node.rule().name());</span>
<span class="fc" id="L1173">            actions.forEach(action -&gt; action.accept(node.node()));</span>
        }

<span class="fc" id="L1176">        node.children().forEach(child -&gt; executeActions(pass, child));</span>

<span class="fc bfc" id="L1178" title="All 4 branches covered.">        if (afterActions.containsKey(pass) &amp;&amp; afterActions.get(pass).containsKey(node.rule().name()))</span>
        {
<span class="fc" id="L1180">            final List&lt;Consumer&lt;Sexpr&gt;&gt; actions = afterActions.get(pass).get(node.rule().name());</span>
<span class="fc" id="L1181">            actions.forEach(action -&gt; action.accept(node.node()));</span>
        }
<span class="fc" id="L1183">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>