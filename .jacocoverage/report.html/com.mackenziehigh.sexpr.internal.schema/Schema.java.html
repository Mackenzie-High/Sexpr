<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Schema.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Sexpr&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.sexpr.internal.schema</a> &gt; <span class="el_source">Schema.java</span></div><h1>Schema.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2017 Michael Mackenzie High
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.mackenziehigh.sexpr.internal.schema;

import com.mackenziehigh.sexpr.SAtom;
import com.mackenziehigh.sexpr.SList;
import com.mackenziehigh.sexpr.Sexpr;
import com.mackenziehigh.sexpr.annotations.After;
import com.mackenziehigh.sexpr.annotations.Before;
import com.mackenziehigh.sexpr.annotations.Condition;
import com.mackenziehigh.sexpr.annotations.Pass;
import java.lang.reflect.Method;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.SortedMap;
import java.util.Stack;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;

/**
 * An instance of this class is a pattern that describes a symbolic-expression.
 * This class provides the actual implementation of schemas.
 */
public final class Schema
{
    /**
     * This counter is used to create names for anonymous rules.
     */
<span class="fc" id="L53">    private static int counter = 1;</span>

    /**
     * This maintains important state during a match attempt.
     */
<span class="fc" id="L58">    private final class MatchState</span>
    {
        /**
         * This stack is used to store match-nodes.
         * Whenever a successful match occurs, it will be placed onto this stack.
         * Matches will be popped of this stack and made the children of other matches.
         */
<span class="fc" id="L65">        private final Stack&lt;Object&gt; matches = new Stack&lt;&gt;();</span>

        /**
         * This was the last node in the symbolic-expression
         * that was successfully matched.
         */
<span class="fc" id="L71">        private Sexpr lastSuccess = null;</span>

        /**
         * This method retrieves the last node in the symbolic-expression
         * that was successfully matched by a rule in the schema,
         * if such a node exists.
         *
         * &lt;p&gt;
         * The last successful node is useful for debugging purposes.
         * &lt;/p&gt;
         *
         * @return the site of the last successful match, if any.
         */
        public Optional&lt;Sexpr&gt; lastSuccess ()
        {
<span class="fc" id="L86">            return Optional.ofNullable(lastSuccess);</span>
        }

        /**
         * This method is invoked whenever a rule begins a match-attempt.
         *
         * @param node is the node that the rule is attempting to match.
         */
        private void enter (final Sexpr node)
        {
<span class="fc" id="L96">            Objects.requireNonNull(node, &quot;node&quot;);</span>
<span class="fc" id="L97">            matches.push(node);</span>
<span class="fc" id="L98">        }</span>

        /**
         * This method is invoked whenever a rule exits a match-attempt
         * due to the fact that the rule successfully matched.
         *
         * @param rule is the rule invoking this method.
         * @param node is the node that was successfully matched.
         * @return the representation of the successful match.
         */
        private MatchNode exitOnSuccess (final Rule rule,
                                         final Sexpr node)
        {
<span class="fc" id="L111">            lastSuccess = node;</span>

            /**
             * Remove any successful child matches from the stack.
             */
<span class="fc" id="L116">            final LinkedList&lt;MatchNode&gt; children = new LinkedList&lt;&gt;();</span>

<span class="fc bfc" id="L118" title="All 2 branches covered.">            while (matches.peek() != node)</span>
            {
<span class="fc" id="L120">                children.addFirst((MatchNode) matches.pop());</span>
            }

            /**
             * Undo push(node) in enter(node).
             */
<span class="fc" id="L126">            matches.pop();</span>

            /**
             * Create the representation of the successful match.
             */
<span class="fc" id="L131">            final MatchNode match = new MatchNode(rule, node, children);</span>
<span class="fc" id="L132">            matches.push(match);</span>

<span class="fc" id="L134">            return match;</span>
        }

        /**
         * This method is invoked whenever a rule exits a match-attempt
         * due to the fact that the rule failed to match the node.
         *
         * @param rule is the rule invoking this method.
         * @param node is the node that was unsuccessfully matched.
         * @return null always.
         */
        private MatchNode exitOnFailure (final Sexpr node)
        {
            /**
             * Remove any successful child matches from the stack.
             */
<span class="fc bfc" id="L150" title="All 2 branches covered.">            while (matches.peek() != node)</span>
            {
<span class="fc" id="L152">                matches.pop();</span>
            }

            /**
             * Undo push(node) in enter(node).
             */
<span class="fc" id="L158">            matches.pop();</span>

<span class="fc" id="L160">            return null;</span>
        }
    }

    /**
     * An instance of this interface is a constraint on a single node in a symbolic-expression.
     */
<span class="fc" id="L167">    abstract class Rule</span>
    {
        /**
         * The default-name starts with a '#' sign,
         * since '#' starts comments in schemas
         * we can be sure that no rule will (ever)
         * have such a name.
         */
<span class="fc" id="L175">        private final String defaultName = &quot;#&quot; + counter++;</span>

        /**
         * This method determines whether this rule matches the given node.
         *
         * &lt;p&gt;
         * This method must invoke state.enter(node).
         * This method must invoke state.exitOnSuccess(node)
         * or state.exitOnFailure(node) depending on the result.
         * &lt;/p&gt;
         *
         * @param state maintains the state of the overall match attempt.
         * @param node may obey the pattern described by this rule.
         * @return an object representing the successful match of this rule,
         * or null, if this rule does not match the given node.
         */
        public abstract MatchNode match (MatchState state,
                                         Sexpr node);

        /**
         * This method retrieves the name of this rule.
         *
         * @return the name of this rule.
         */
        public String name ()
        {
<span class="fc" id="L201">            return defaultName;</span>
        }

        /**
         * This method determines whether this is an implicitly named rule.
         *
         * @return false, iff the user named this rule.
         */
        public boolean isAnonymous ()
        {
<span class="nc" id="L211">            return true;</span>
        }
    }

    /**
     * An instance of this interface represents a single element in a sequence-rule.
     */
    interface SequenceElement
    {
        /**
         * This method retrieves the name of the rule that describes the sequence element.
         *
         * @return the name of a rule in the schema.
         */
        public String element ();

        /**
         * This method retrieves the minimum number of times that the element must repeat.
         *
         * @return the lower bound of the sequence-element.
         */
        public int minimum ();

        /**
         * This method retrieves the maximum number of times that the element must repeat.
         *
         * @return the upper bound of the sequence-element.
         */
        public int maximum ();
    }

    /**
     * This function will be invoked on failed match attempts.
     */
<span class="fc" id="L245">    private Consumer&lt;Optional&lt;Sexpr&gt;&gt; failureHandler = x -&gt;</span>
    {
        // Pass.
<span class="fc" id="L248">    };</span>

    /**
     * These are all of the rules that are defined within the schema.
     */
<span class="fc" id="L253">    private final SortedMap&lt;String, Rule&gt; rules = new TreeMap&lt;&gt;();</span>

    /**
     * This supplier supplies the name of the root rule of the schema.
     */
<span class="fc" id="L258">    private String root = &quot;root&quot;;</span>

    /**
     * This map maps the names of user-defined conditions
     * to the definitions of those conditions, if any.
     */
<span class="fc" id="L264">    private final Map&lt;String, Predicate&lt;Sexpr&gt;&gt; conditions = new TreeMap&lt;&gt;();</span>

    /**
     * These are the names of the user-defined translation passes.
     */
<span class="fc" id="L269">    private final List&lt;String&gt; passes = new LinkedList&lt;&gt;();</span>

    /**
     * This map maps the name of a translation pass (P) to a map that maps the name
     * of a rule (R) in the schema to a list of user-defined actions (A1 ... AN)
     * that will be performed for each successful match of (R) during pass (P).
     */
<span class="fc" id="L276">    private final Map&lt;String, Map&lt;String, List&lt;Consumer&lt;Sexpr&gt;&gt;&gt;&gt; beforeActions = new TreeMap&lt;&gt;();</span>

    /**
     * This map maps the name of a translation pass (P) to a map that maps the name
     * of a rule (R) in the schema to a list of user-defined actions (A1 ... AN)
     * that will be performed for each successful match of (R) during pass (P).
     */
<span class="fc" id="L283">    private final Map&lt;String, Map&lt;String, List&lt;Consumer&lt;Sexpr&gt;&gt;&gt;&gt; afterActions = new TreeMap&lt;&gt;();</span>

    /**
     * These are the names of all of the rules that have been used in the schema.
     * This may include undefined rules due to typos, etc, made by the user.
     * Such problems need to be detected and reported.
     */
<span class="fc" id="L290">    private final Set&lt;String&gt; usedRules = new TreeSet&lt;&gt;();</span>

    /**
     * Sole Constructor.
     */
    public Schema ()
<span class="fc" id="L296">    {</span>
        /**
         * Define the predefined rules, whose names always start with a '$' by convention.
         */
<span class="pc" id="L300">        rules.put(&quot;$ANY&quot;, defineRuleByPredicate(x -&gt; true));</span>
<span class="pc bpc" id="L301" title="1 of 4 branches missed.">        rules.put(&quot;$BOOLEAN&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.toAtom().asBoolean().isPresent()));</span>
<span class="pc bnc" id="L302" title="All 4 branches missed.">        rules.put(&quot;$CHAR&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.toAtom().asChar().isPresent()));</span>
<span class="pc bpc" id="L303" title="1 of 4 branches missed.">        rules.put(&quot;$BYTE&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.toAtom().asByte().isPresent()));</span>
<span class="pc bpc" id="L304" title="1 of 4 branches missed.">        rules.put(&quot;$SHORT&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.toAtom().asShort().isPresent()));</span>
<span class="pc bpc" id="L305" title="1 of 4 branches missed.">        rules.put(&quot;$INT&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.toAtom().asInt().isPresent()));</span>
<span class="pc bpc" id="L306" title="1 of 4 branches missed.">        rules.put(&quot;$LONG&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.toAtom().asLong().isPresent()));</span>
<span class="pc bnc" id="L307" title="All 4 branches missed.">        rules.put(&quot;$FLOAT&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.toAtom().asFloat().isPresent()));</span>
<span class="pc bnc" id="L308" title="All 4 branches missed.">        rules.put(&quot;$DOUBLE&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.toAtom().asDouble().isPresent()));</span>
<span class="pc bnc" id="L309" title="All 4 branches missed.">        rules.put(&quot;$CLASS&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.toAtom().asClass().isPresent()));</span>
<span class="pc" id="L310">        rules.put(&quot;$ATOM&quot;, defineRuleByPredicate(x -&gt; x.isAtom()));</span>
<span class="pc" id="L311">        rules.put(&quot;$LIST&quot;, defineRuleByPredicate(x -&gt; x.isList()));</span>
<span class="fc" id="L312">    }</span>

    /**
     * This method sets the failure-handler.
     *
     * @param handler is the new handler.
     */
    public void setFailureHandler (final Consumer&lt;Optional&lt;Sexpr&gt;&gt; handler)
    {
<span class="fc" id="L321">        Objects.requireNonNull(handler, &quot;handler&quot;);</span>
<span class="fc" id="L322">        failureHandler = handler;</span>
<span class="fc" id="L323">    }</span>

    /**
     * This method causes a rule to be added to this schema.
     *
     * @param rule is the rule to add.
     * @return the rule.
     */
    private Rule define (final Rule rule)
    {
<span class="fc" id="L333">        Objects.requireNonNull(rule, &quot;rule&quot;);</span>
<span class="fc" id="L334">        rules.put(rule.name(), rule);</span>
<span class="fc" id="L335">        return rule;</span>
    }

    /**
     * Use this method to specify the root rule of this schema.
     *
     * @param root is the name of the root rule.
     */
    public void defineRoot (final String root)
    {
<span class="fc" id="L345">        Objects.requireNonNull(root, &quot;root&quot;);</span>
<span class="fc" id="L346">        usedRules.add(root);</span>
<span class="fc" id="L347">        this.root = root;</span>
<span class="fc" id="L348">    }</span>

    /**
     * This method defines a condition that can be referenced by a 'require' rule.
     *
     * @param name is the name of the user-defined condition.
     * @param condition is the user-defined condition itself.
     */
    public void defineCondition (final String name,
                                 final Predicate&lt;Sexpr&gt; condition)
    {
<span class="fc" id="L359">        Objects.requireNonNull(name, &quot;name&quot;);</span>
<span class="fc" id="L360">        Objects.requireNonNull(condition, &quot;condition&quot;);</span>
<span class="fc" id="L361">        conditions.put(name, condition);</span>
<span class="fc" id="L362">    }</span>

    /**
     * Use this method to create a rule that provides a name for another rule.
     *
     * @param name is the name of the new rule.
     * @param body is the name of the referenced (usually anonymous) rule.
     * @return the new rule.
     */
    final Rule defineNamedRule (final String name,
                                final String body)
    {
<span class="fc" id="L374">        Objects.requireNonNull(name, &quot;name&quot;);</span>
<span class="fc" id="L375">        Objects.requireNonNull(body, &quot;body&quot;);</span>

<span class="fc bfc" id="L377" title="All 2 branches covered.">        if (rules.containsKey(name))</span>
        {
<span class="fc" id="L379">            throw new IllegalStateException(&quot;Duplicate Rule: &quot; + name);</span>
        }

<span class="fc" id="L382">        usedRules.add(name);</span>
<span class="fc" id="L383">        usedRules.add(body);</span>

<span class="fc" id="L385">        final Rule rule = new Rule()</span>
<span class="fc" id="L386">        {</span>
            @Override
            public String name ()
            {
<span class="fc" id="L390">                return name;</span>
            }

            @Override
            public boolean isAnonymous ()
            {
<span class="nc" id="L396">                return false;</span>
            }

            @Override
            public MatchNode match (final MatchState state,
                                    final Sexpr node)
            {
<span class="fc" id="L403">                state.enter(node);</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">                final boolean answer = rules.get(body).match(state, node) != null;</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">                return answer ? state.exitOnSuccess(this, node) : state.exitOnFailure(node);</span>
            }
        };

<span class="fc" id="L409">        return define(rule);</span>
    }

    /**
     * Use this method to create a rule that is a lazy reference to another rule.
     *
     * @param name is the name of the new rule.
     * @return the new rule.
     */
    final Rule defineReference (final String name)
    {
<span class="fc" id="L420">        Objects.requireNonNull(name, &quot;name&quot;);</span>

<span class="fc" id="L422">        usedRules.add(name);</span>

        /**
         * This type of rule is a special-case.
         * Do *not* invoke enter(*), exitOnSuccess(*), or exitOnFailure(*),
         * because that would break how action execution works.
         */
<span class="fc" id="L429">        final Rule rule = new Rule()</span>
<span class="fc" id="L430">        {</span>
            @Override
            public MatchNode match (final MatchState state,
                                    final Sexpr node)
            {
<span class="fc" id="L435">                return rules.get(name).match(state, node);</span>
            }
        };

<span class="fc" id="L439">        return define(rule);</span>
    }

    /**
     * Use this method to define a rule that will only successfully match
     * a node when a series of operand rules always match the node.
     *
     * @param operands must all match the same node in order for the new rule to match.
     * @return the new rule.
     */
    final Rule defineAndRule (final List&lt;String&gt; operands)
    {
<span class="fc" id="L451">        Objects.requireNonNull(operands, &quot;operands&quot;);</span>
<span class="fc" id="L452">        operands.forEach(operand -&gt; Objects.requireNonNull(operand, &quot;operand&quot;));</span>

<span class="fc" id="L454">        usedRules.addAll(operands);</span>

<span class="fc" id="L456">        final Rule rule = new Rule()</span>
<span class="fc" id="L457">        {</span>
            @Override
            public MatchNode match (final MatchState state,
                                    final Sexpr node)
            {
<span class="fc" id="L462">                state.enter(node);</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">                final boolean answer = operands.stream().map(name -&gt; rules.get(name)).allMatch(rule -&gt; rule.match(state, node) != null);</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">                return answer ? state.exitOnSuccess(this, node) : state.exitOnFailure(node);</span>
            }
        };

<span class="fc" id="L468">        return define(rule);</span>
    }

    /**
     * Use this method to define a rule that will successfully match a node
     * when the first of a series of operand rules matches the node.
     *
     * @param operands are the options that may match the node.
     * @return the new rule.
     */
    final Rule defineOrRule (final List&lt;String&gt; operands)
    {
<span class="fc" id="L480">        Objects.requireNonNull(operands, &quot;operands&quot;);</span>
<span class="fc" id="L481">        operands.forEach(operand -&gt; Objects.requireNonNull(operand, &quot;operand&quot;));</span>

<span class="fc" id="L483">        usedRules.addAll(operands);</span>

<span class="fc" id="L485">        final Rule rule = new Rule()</span>
<span class="fc" id="L486">        {</span>
            @Override
            public MatchNode match (final MatchState state,
                                    final Sexpr node)
            {
<span class="fc" id="L491">                state.enter(node);</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">                final boolean answer = operands.stream().map(name -&gt; rules.get(name)).anyMatch(rule -&gt; rule.match(state, node) != null);</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">                return answer ? state.exitOnSuccess(this, node) : state.exitOnFailure(node);</span>
            }
        };

<span class="fc" id="L497">        return define(rule);</span>
    }

    /**
     * Use this method to define a rule that will only successfully
     * match a node when a given operand rule fails to match.
     *
     * @param operand the rule that is negated by the new rule.
     * @return the new rule.
     */
    final Rule defineNotRule (final String operand)
    {
<span class="fc" id="L509">        Objects.requireNonNull(operand, &quot;operand&quot;);</span>

<span class="fc" id="L511">        usedRules.add(operand);</span>

<span class="fc" id="L513">        final Rule rule = new Rule()</span>
<span class="fc" id="L514">        {</span>
            @Override
            public MatchNode match (final MatchState state,
                                    final Sexpr node)
            {
<span class="fc" id="L519">                state.enter(node);</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">                final boolean answer = rules.get(operand).match(state, node) == null;</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">                return answer ? state.exitOnSuccess(this, node) : state.exitOnFailure(node);</span>
            }
        };

<span class="fc" id="L525">        return define(rule);</span>
    }

    /**
     * Use this method to define a rule that will only successfully
     * match a symbolic-list that obeys a proscribed sequence.
     *
     * @param operands describe the elements in the sequence.
     * @return the new rule.
     */
    final Rule defineSequenceRule (final List&lt;? extends SequenceElement&gt; operands)
    {
<span class="fc" id="L537">        Objects.requireNonNull(operands, &quot;operands&quot;);</span>
<span class="fc" id="L538">        operands.forEach(operand -&gt; Objects.requireNonNull(operand, &quot;operand&quot;));</span>

<span class="fc bfc" id="L540" title="All 2 branches covered.">        for (SequenceElement operand : operands)</span>
        {
<span class="fc bfc" id="L542" title="All 2 branches covered.">            if (operand.maximum() &lt; operand.minimum())</span>
            {
<span class="fc" id="L544">                final String message = String.format(&quot;Invalid Range: { %d, %d }&quot;,</span>
<span class="fc" id="L545">                                                     operand.minimum(),</span>
<span class="fc" id="L546">                                                     operand.maximum());</span>
<span class="fc" id="L547">                throw new IllegalStateException(message);</span>
            }
<span class="fc" id="L549">        }</span>

<span class="fc" id="L551">        operands.forEach(x -&gt; usedRules.add(x.element()));</span>

<span class="fc" id="L553">        final Rule rule = new Rule()</span>
<span class="fc" id="L554">        {</span>
            @Override
            public MatchNode match (final MatchState state,
                                    final Sexpr node)
            {
<span class="fc" id="L559">                return sequenceMatch(this, operands, state, node);</span>
            }
        };

<span class="fc" id="L563">        return define(rule);</span>
    }

    private MatchNode sequenceMatch (final Rule rule,
                                     final List&lt;? extends SequenceElement&gt; operands,
                                     final MatchState state,
                                     final Sexpr node)
    {
<span class="fc" id="L571">        Objects.requireNonNull(rule, &quot;rule&quot;);</span>
<span class="fc" id="L572">        Objects.requireNonNull(operands, &quot;operands&quot;);</span>
<span class="fc" id="L573">        operands.forEach(operand -&gt; Objects.requireNonNull(operand, &quot;operand&quot;));</span>
<span class="fc" id="L574">        Objects.requireNonNull(state, &quot;state&quot;);</span>
<span class="fc" id="L575">        Objects.requireNonNull(node, &quot;node&quot;);</span>

<span class="fc" id="L577">        state.enter(node);</span>

<span class="pc bpc" id="L579" title="1 of 2 branches missed.">        if (node.isList() == false)</span>
        {
<span class="nc" id="L581">            return state.exitOnFailure(node);</span>
        }

<span class="fc" id="L584">        final Deque&lt;Sexpr&gt; nodes = new ArrayDeque&lt;&gt;(node.toList());</span>

<span class="fc bfc" id="L586" title="All 2 branches covered.">seq:    for (SequenceElement operand : operands)</span>
        {
            int i;

            /**
             * The operand rule must match at least the minimum number of times.
             */
<span class="fc bfc" id="L593" title="All 2 branches covered.">            for (i = 0; i &lt; operand.minimum(); i++)</span>
            {
                /**
                 * If no more nodes are in the list, then the rule has failed to match,
                 * because the minium match count was not reached for this operand rule.
                 */
<span class="pc bpc" id="L599" title="1 of 2 branches missed.">                if (nodes.isEmpty())</span>
                {
<span class="nc" id="L601">                    return state.exitOnFailure(node);</span>
                }

<span class="fc" id="L604">                final Sexpr next = nodes.peek();</span>
<span class="fc" id="L605">                final MatchNode match = rules.get(operand.element()).match(state, next);</span>

<span class="fc bfc" id="L607" title="All 2 branches covered.">                if (match == null)</span>
                {
<span class="fc" id="L609">                    return state.exitOnFailure(node);</span>
                }
                else
                {
<span class="fc" id="L613">                    nodes.pop();</span>
                }
            }

            /**
             * The operand rule can continue to match until the maximum is reached.
             */
<span class="fc bfc" id="L620" title="All 2 branches covered.">            for (i = i + 0; i &lt; operand.maximum(); i++)</span>
            {
                /**
                 * If no more nodes are in the list, then goto the next operand rule,
                 * because the tail rules may be require to match more than zero times.
                 * In that case, the overall sequence rule has failed,
                 * even though the current operand rule succeeded.
                 */
<span class="fc bfc" id="L628" title="All 2 branches covered.">                if (nodes.isEmpty())</span>
                {
<span class="fc" id="L630">                    continue seq;</span>
                }

<span class="fc" id="L633">                final Sexpr next = nodes.peek();</span>
<span class="fc" id="L634">                final MatchNode match = rules.get(operand.element()).match(state, next);</span>

<span class="fc bfc" id="L636" title="All 2 branches covered.">                if (match == null)</span>
                {
<span class="fc" id="L638">                    continue seq; // Go to the next operand rule.</span>
                }
                else
                {
<span class="fc" id="L642">                    nodes.pop();</span>
                }
            }
<span class="fc" id="L645">        }</span>

        /**
         * If there are still more nodes in the list,
         * then the sequence-rule only described the prefix of the list,
         * which we do not consider to be a true match of the list.
         */
<span class="fc bfc" id="L652" title="All 2 branches covered.">        if (nodes.isEmpty() == false)</span>
        {
<span class="fc" id="L654">            return state.exitOnFailure(node);</span>
        }

<span class="fc" id="L657">        return state.exitOnSuccess(rule, node);</span>
    }

    /**
     * Use this method to define a rule that will only successfully match
     * a symbolic-atom whose content() matches a given regular-expression.
     *
     * @param pattern is the given symbolic-expression.
     * @return the new rule.
     */
    final Rule defineRegexRule (final String pattern)
    {
<span class="fc" id="L669">        Objects.requireNonNull(pattern, &quot;pattern&quot;);</span>

<span class="pc bpc" id="L671" title="1 of 4 branches missed.">        return defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.toAtom().content().matches(pattern));</span>
    }

    /**
     * Use this method to define a rule that will only successfully
     * match a symbolic-atom whose content() equals the given value.
     *
     * @param value is the value that must be the content() of the node.
     * @return the new rule.
     */
    final Rule defineConstantRule (final String value)
    {
<span class="fc" id="L683">        Objects.requireNonNull(value, &quot;value&quot;);</span>

<span class="pc bpc" id="L685" title="2 of 4 branches missed.">        return defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.toAtom().content().equals(value));</span>
    }

    /**
     * Use this method to define a new rule that will only successfully
     * match a node when a user-defined predicate matches the node.
     *
     * @param name is the name of the user-defined requirement.
     * @return the new rule.
     */
    final Rule definePredicateRule (final String name)
    {
<span class="fc" id="L697">        Objects.requireNonNull(name, &quot;name&quot;);</span>

<span class="fc" id="L699">        return defineRuleByPredicate(x -&gt; Optional.ofNullable(conditions.get(name)).get().test(x));</span>
    }

    /**
     * Use this method to define a new rule that will only successfully
     * match a node when a given predicate matches the node.
     *
     * @param condition is the predicate.
     * @return the new rule.
     */
    private Rule defineRuleByPredicate (final Predicate&lt;Sexpr&gt; condition)
    {
<span class="fc" id="L711">        Objects.requireNonNull(condition, &quot;condition&quot;);</span>

<span class="fc" id="L713">        final Rule rule = new Rule()</span>
<span class="fc" id="L714">        {</span>
            @Override
            public MatchNode match (final MatchState state,
                                    final Sexpr node)
            {
<span class="fc" id="L719">                state.enter(node);</span>
<span class="fc" id="L720">                final boolean answer = condition.test(node);</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">                return answer ? state.exitOnSuccess(this, node) : state.exitOnFailure(node);</span>
            }
        };

<span class="fc" id="L725">        return define(rule);</span>
    }

    /**
     * Use this method to define another compiler pass.
     *
     * &lt;p&gt;
     * The order in which this method is invoked will
     * define the order of compiler passes relative
     * to one another.
     * &lt;/p&gt;
     *
     * @param name is the name of the new compiler pass.
     */
    public void definePass (final String name)
    {
<span class="fc" id="L741">        Objects.requireNonNull(name, &quot;name&quot;);</span>
<span class="fc" id="L742">        passes.add(name);</span>
<span class="fc" id="L743">    }</span>

    public void defineBeforeAction (final String pass,
                                    final String rule,
                                    final Consumer&lt;Sexpr&gt; action)
    {
<span class="fc" id="L749">        Objects.requireNonNull(pass, &quot;pass&quot;);</span>
<span class="fc" id="L750">        Objects.requireNonNull(rule, &quot;rule&quot;);</span>
<span class="fc" id="L751">        Objects.requireNonNull(action, &quot;action&quot;);</span>

<span class="fc bfc" id="L753" title="All 2 branches covered.">        if (beforeActions.containsKey(pass) == false)</span>
        {
<span class="fc" id="L755">            beforeActions.put(pass, new TreeMap&lt;&gt;());</span>
        }

<span class="pc bpc" id="L758" title="1 of 2 branches missed.">        if (beforeActions.get(pass).containsKey(rule) == false)</span>
        {
<span class="fc" id="L760">            beforeActions.get(pass).put(rule, new LinkedList&lt;&gt;());</span>
        }

<span class="fc" id="L763">        beforeActions.get(pass).get(rule).add(action);</span>
<span class="fc" id="L764">    }</span>

    public void defineAfterAction (final String pass,
                                   final String rule,
                                   final Consumer&lt;Sexpr&gt; action)
    {
<span class="fc" id="L770">        Objects.requireNonNull(pass, &quot;pass&quot;);</span>
<span class="fc" id="L771">        Objects.requireNonNull(rule, &quot;rule&quot;);</span>
<span class="fc" id="L772">        Objects.requireNonNull(action, &quot;action&quot;);</span>

<span class="fc bfc" id="L774" title="All 2 branches covered.">        if (afterActions.containsKey(pass) == false)</span>
        {
<span class="fc" id="L776">            afterActions.put(pass, new TreeMap&lt;&gt;());</span>
        }

<span class="pc bpc" id="L779" title="1 of 2 branches missed.">        if (afterActions.get(pass).containsKey(rule) == false)</span>
        {
<span class="fc" id="L781">            afterActions.get(pass).put(rule, new LinkedList&lt;&gt;());</span>
        }

<span class="fc" id="L784">        afterActions.get(pass).get(rule).add(action);</span>
<span class="fc" id="L785">    }</span>

    /**
     * Given an object containing properly annotated methods,
     * define the conditions and actions defined therein.
     *
     * @param object contains condition and action definitions.
     */
    public void defineViaReflection (final Object object)
    {
<span class="fc" id="L795">        final Optional&lt;String&gt; defaultPass = getDefaultPass(object);</span>

<span class="fc bfc" id="L797" title="All 2 branches covered.">        for (Method method : object.getClass().getMethods())</span>
        {
<span class="fc bfc" id="L799" title="All 2 branches covered.">            if (method.isAnnotationPresent(Condition.class))</span>
            {
<span class="fc" id="L801">                defineConditionViaReflection(object, method);</span>
            }

<span class="fc bfc" id="L804" title="All 2 branches covered.">            if (method.isAnnotationPresent(Before.class))</span>
            {
<span class="fc" id="L806">                defineBeforeActionByReflection(defaultPass, object, method);</span>
            }

<span class="fc bfc" id="L809" title="All 2 branches covered.">            if (method.isAnnotationPresent(After.class))</span>
            {
<span class="fc" id="L811">                defineAfterActionByReflection(defaultPass, object, method);</span>
            }
        }
<span class="fc" id="L814">    }</span>

    private Optional&lt;String&gt; getDefaultPass (final Object object)
    {
<span class="fc bfc" id="L818" title="All 2 branches covered.">        if (object.getClass().isAnnotationPresent(Pass.class))</span>
        {
<span class="fc" id="L820">            final String name = object.getClass().getAnnotation(Pass.class).value();</span>
<span class="fc" id="L821">            return Optional.of(name);</span>
        }
        else
        {
<span class="fc" id="L825">            return Optional.empty();</span>
        }
    }

    private String getPass (final Optional&lt;String&gt; defaultPass,
                            final Method method)
    {
<span class="fc bfc" id="L832" title="All 2 branches covered.">        if (method.isAnnotationPresent(Pass.class))</span>
        {
<span class="fc" id="L834">            final String name = method.getAnnotation(Pass.class).value();</span>
<span class="fc" id="L835">            return name;</span>
        }
<span class="pc bpc" id="L837" title="1 of 2 branches missed.">        else if (defaultPass.isPresent())</span>
        {
<span class="fc" id="L839">            return defaultPass.get();</span>
        }
        else
        {
<span class="nc" id="L843">            throw new IllegalArgumentException(&quot;No translation pass was specified on either the class or method.&quot;);</span>
        }
    }

    private void defineConditionViaReflection (final Object object,
                                               final Method method)
    {
        /**
         * Obtain the user-defined name of the condition.
         */
<span class="fc" id="L853">        final String name = method.getAnnotation(Condition.class).value();</span>

        /**
         * The method cannot throw any checked exceptions.
         */
<span class="fc bfc" id="L858" title="All 2 branches covered.">        if (method.getExceptionTypes().length != 0)</span>
        {
<span class="fc" id="L860">            final String message = String.format(&quot;Do *not* throw checked exceptions in (%s).&quot;, method.toString());</span>
<span class="fc" id="L861">            throw new IllegalArgumentException(message);</span>
        }

        /**
         * The return-type of the method must be boolean.
         */
<span class="fc bfc" id="L867" title="All 2 branches covered.">        if (method.getReturnType().equals(boolean.class) == false)</span>
        {
<span class="fc" id="L869">            final String message = String.format(&quot;You must return boolean from (%s), not %s.&quot;,</span>
<span class="fc" id="L870">                                                 method.toString(),</span>
<span class="fc" id="L871">                                                 method.getReturnType().getName());</span>
<span class="fc" id="L872">            throw new IllegalArgumentException(message);</span>
        }

        /**
         * The method must take exactly one argument,
         * which must be a symbolic-expression.
         */
<span class="fc bfc" id="L879" title="All 2 branches covered.">        if (method.getParameterCount() != 1)</span>
        {
<span class="fc" id="L881">            final String message = String.format(&quot;Method (%s) must take exactly one parameter.&quot;, method.toString());</span>
<span class="fc" id="L882">            throw new IllegalArgumentException(message);</span>
        }
<span class="fc bfc" id="L884" title="All 2 branches covered.">        else if (method.getParameterTypes()[0].equals(Sexpr.class))</span>
        {
<span class="fc" id="L886">            final Function&lt;Sexpr, Object&gt; invocation = createInvocation(object, method);</span>
<span class="fc" id="L887">            final Predicate&lt;Sexpr&gt; condition = x -&gt; (Boolean) invocation.apply(x);</span>
<span class="fc" id="L888">            defineCondition(name, condition);</span>
<span class="fc" id="L889">        }</span>
<span class="fc bfc" id="L890" title="All 2 branches covered.">        else if (method.getParameterTypes()[0].equals(SAtom.class))</span>
        {
<span class="fc" id="L892">            final Function&lt;SAtom, Object&gt; invocation = createInvocation(object, method);</span>
<span class="fc bfc" id="L893" title="All 2 branches covered.">            final Predicate&lt;Sexpr&gt; condition = x -&gt; x.isAtom() ? (Boolean) invocation.apply(x.toAtom()) : false;</span>
<span class="fc" id="L894">            defineCondition(name, condition);</span>
<span class="fc" id="L895">        }</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">        else if (method.getParameterTypes()[0].equals(SList.class))</span>
        {
<span class="fc" id="L898">            final Function&lt;SList, Object&gt; invocation = createInvocation(object, method);</span>
<span class="fc bfc" id="L899" title="All 2 branches covered.">            final Predicate&lt;Sexpr&gt; condition = x -&gt; x.isList() ? (Boolean) invocation.apply(x.toList()) : false;</span>
<span class="fc" id="L900">            defineCondition(name, condition);</span>
<span class="fc" id="L901">        }</span>
        else
        {
<span class="fc" id="L904">            final String message = String.format(&quot;Method (%s) must take a %s|%s|%s as its only parameter.&quot;,</span>
<span class="fc" id="L905">                                                 method.toString(),</span>
<span class="fc" id="L906">                                                 Sexpr.class.getName(),</span>
<span class="fc" id="L907">                                                 SAtom.class.getName(),</span>
<span class="fc" id="L908">                                                 SList.class.getName());</span>
<span class="fc" id="L909">            throw new IllegalArgumentException(message);</span>
        }
<span class="fc" id="L911">    }</span>

    private void defineBeforeActionByReflection (final Optional&lt;String&gt; defaultPass,
                                                 final Object object,
                                                 final Method method)
    {
        /**
         * Obtain the name of the translation pass that this action applies to.
         */
<span class="fc" id="L920">        final String pass = getPass(defaultPass, method);</span>

        /**
         * Obtain the user-defined name of the rule that this action applies to.
         */
<span class="fc" id="L925">        final String rule = method.getAnnotation(Before.class).value();</span>

        /**
         * The method cannot throw any checked exceptions.
         */
<span class="fc bfc" id="L930" title="All 2 branches covered.">        if (method.getExceptionTypes().length != 0)</span>
        {
<span class="fc" id="L932">            final String message = String.format(&quot;Do *not* throw checked exceptions in (%s).&quot;, method.toString());</span>
<span class="fc" id="L933">            throw new IllegalArgumentException(message);</span>
        }

        /**
         * The return-type of the method must be void.
         */
<span class="fc bfc" id="L939" title="All 2 branches covered.">        if (method.getReturnType().equals(void.class) == false)</span>
        {
<span class="fc" id="L941">            final String message = String.format(&quot;You must return boolean from (%s), not %s.&quot;,</span>
<span class="fc" id="L942">                                                 method.toString(),</span>
<span class="fc" id="L943">                                                 method.getReturnType().getName());</span>
<span class="fc" id="L944">            throw new IllegalArgumentException(message);</span>
        }

        /**
         * The method must take exactly one argument,
         * which must be a symbolic-expression.
         */
<span class="fc bfc" id="L951" title="All 2 branches covered.">        if (method.getParameterCount() != 1)</span>
        {
<span class="fc" id="L953">            final String message = String.format(&quot;Method (%s) must take exactly one parameter.&quot;, method.toString());</span>
<span class="fc" id="L954">            throw new IllegalArgumentException(message);</span>
        }
<span class="fc bfc" id="L956" title="All 2 branches covered.">        else if (method.getParameterTypes()[0].equals(Sexpr.class))</span>
        {
<span class="fc" id="L958">            final Function&lt;Sexpr, Object&gt; invocation = createInvocation(object, method);</span>
<span class="fc" id="L959">            final Consumer&lt;Sexpr&gt; action = x -&gt; invocation.apply(x);</span>
<span class="fc" id="L960">            defineBeforeAction(pass, rule, action);</span>
<span class="fc" id="L961">        }</span>
<span class="fc bfc" id="L962" title="All 2 branches covered.">        else if (method.getParameterTypes()[0].equals(SAtom.class))</span>
        {
<span class="fc" id="L964">            final Function&lt;SAtom, Object&gt; invocation = createInvocation(object, method);</span>
<span class="fc" id="L965">            final Consumer&lt;Sexpr&gt; action = x -&gt; invocation.apply(x.toAtom());</span>
<span class="fc" id="L966">            defineBeforeAction(pass, rule, action);</span>
<span class="fc" id="L967">        }</span>
<span class="fc bfc" id="L968" title="All 2 branches covered.">        else if (method.getParameterTypes()[0].equals(SList.class))</span>
        {
<span class="fc" id="L970">            final Function&lt;SList, Object&gt; invocation = createInvocation(object, method);</span>
<span class="fc" id="L971">            final Consumer&lt;Sexpr&gt; action = x -&gt; invocation.apply(x.toList());</span>
<span class="fc" id="L972">            defineBeforeAction(pass, rule, action);</span>
<span class="fc" id="L973">        }</span>
        else
        {
<span class="fc" id="L976">            final String message = String.format(&quot;Method (%s) must take a %s|%s|%s as its only parameter.&quot;,</span>
<span class="fc" id="L977">                                                 method.toString(),</span>
<span class="fc" id="L978">                                                 Sexpr.class.getName(),</span>
<span class="fc" id="L979">                                                 SAtom.class.getName(),</span>
<span class="fc" id="L980">                                                 SList.class.getName());</span>
<span class="fc" id="L981">            throw new IllegalArgumentException(message);</span>
        }
<span class="fc" id="L983">    }</span>

    private void defineAfterActionByReflection (final Optional&lt;String&gt; defaultPass,
                                                final Object object,
                                                final Method method)
    {
        /**
         * Obtain the name of the translation pass that this action applies to.
         */
<span class="fc" id="L992">        final String pass = getPass(defaultPass, method);</span>

        /**
         * Obtain the user-defined name of the rule that this action applies to.
         */
<span class="fc" id="L997">        final String rule = method.getAnnotation(After.class).value();</span>

        /**
         * The method cannot throw any checked exceptions.
         */
<span class="fc bfc" id="L1002" title="All 2 branches covered.">        if (method.getExceptionTypes().length != 0)</span>
        {
<span class="fc" id="L1004">            final String message = String.format(&quot;Do *not* throw checked exceptions in (%s).&quot;, method.toString());</span>
<span class="fc" id="L1005">            throw new IllegalArgumentException(message);</span>
        }

        /**
         * The return-type of the method must be void.
         */
<span class="fc bfc" id="L1011" title="All 2 branches covered.">        if (method.getReturnType().equals(void.class) == false)</span>
        {
<span class="fc" id="L1013">            final String message = String.format(&quot;You must return boolean from (%s), not %s.&quot;,</span>
<span class="fc" id="L1014">                                                 method.toString(),</span>
<span class="fc" id="L1015">                                                 method.getReturnType().getName());</span>
<span class="fc" id="L1016">            throw new IllegalArgumentException(message);</span>
        }

        /**
         * The method must take exactly one argument,
         * which must be a symbolic-expression.
         */
<span class="fc bfc" id="L1023" title="All 2 branches covered.">        if (method.getParameterCount() != 1)</span>
        {
<span class="fc" id="L1025">            final String message = String.format(&quot;Method (%s) must take exactly one parameter.&quot;, method.toString());</span>
<span class="fc" id="L1026">            throw new IllegalArgumentException(message);</span>
        }
<span class="fc bfc" id="L1028" title="All 2 branches covered.">        else if (method.getParameterTypes()[0].equals(Sexpr.class))</span>
        {
<span class="fc" id="L1030">            final Function&lt;Sexpr, Object&gt; invocation = createInvocation(object, method);</span>
<span class="fc" id="L1031">            final Consumer&lt;Sexpr&gt; action = x -&gt; invocation.apply(x);</span>
<span class="fc" id="L1032">            defineAfterAction(pass, rule, action);</span>
<span class="fc" id="L1033">        }</span>
<span class="fc bfc" id="L1034" title="All 2 branches covered.">        else if (method.getParameterTypes()[0].equals(SAtom.class))</span>
        {
<span class="fc" id="L1036">            final Function&lt;SAtom, Object&gt; invocation = createInvocation(object, method);</span>
<span class="fc" id="L1037">            final Consumer&lt;Sexpr&gt; action = x -&gt; invocation.apply(x.toAtom());</span>
<span class="fc" id="L1038">            defineAfterAction(pass, rule, action);</span>
<span class="fc" id="L1039">        }</span>
<span class="fc bfc" id="L1040" title="All 2 branches covered.">        else if (method.getParameterTypes()[0].equals(SList.class))</span>
        {
<span class="fc" id="L1042">            final Function&lt;SList, Object&gt; invocation = createInvocation(object, method);</span>
<span class="fc" id="L1043">            final Consumer&lt;Sexpr&gt; action = x -&gt; invocation.apply(x.toList());</span>
<span class="fc" id="L1044">            defineAfterAction(pass, rule, action);</span>
<span class="fc" id="L1045">        }</span>
        else
        {
<span class="fc" id="L1048">            final String message = String.format(&quot;Method (%s) must take a %s|%s|%s as its only parameter.&quot;,</span>
<span class="fc" id="L1049">                                                 method.toString(),</span>
<span class="fc" id="L1050">                                                 Sexpr.class.getName(),</span>
<span class="fc" id="L1051">                                                 SAtom.class.getName(),</span>
<span class="fc" id="L1052">                                                 SList.class.getName());</span>
<span class="fc" id="L1053">            throw new IllegalArgumentException(message);</span>
        }
<span class="fc" id="L1055">    }</span>

    private &lt;T&gt; Function&lt;T, Object&gt; createInvocation (final Object object,
                                                      final Method method)
    {
<span class="fc" id="L1060">        final Function&lt;T, Object&gt; function = x -&gt;</span>
        {
            try
            {
<span class="fc" id="L1064">                method.setAccessible(true);</span>
<span class="fc" id="L1065">                return method.invoke(object, x);</span>
            }
<span class="nc" id="L1067">            catch (Throwable ex)</span>
            {
<span class="nc" id="L1069">                throw new RuntimeException(x.toString(), ex);</span>
            }
        };

<span class="fc" id="L1073">        return function;</span>
    }

    /**
     * This method performs a match-attempt.
     *
     * @param tree is the symbolic-expression that this schema may match.
     * @return true, iff the match was successful.
     */
    public boolean match (final Sexpr tree)
    {
<span class="fc" id="L1084">        Objects.requireNonNull(tree, &quot;tree&quot;);</span>

        /**
         * Verify that this schema is well-defined.
         */
<span class="fc" id="L1089">        validate();</span>

        /**
         * Perform the match attempt.
         */
<span class="fc" id="L1094">        final MatchState state = new MatchState();</span>
<span class="fc" id="L1095">        final Rule rootRule = rules.get(root);</span>
<span class="fc" id="L1096">        final MatchNode match = rootRule.match(state, tree);</span>

        /**
         * If the match-attempt failed, then report the failure;
         * otherwise, execute the user-defined passes and actions.
         */
<span class="fc bfc" id="L1102" title="All 2 branches covered.">        if (match == null)</span>
        {
<span class="fc" id="L1104">            failureHandler.accept(state.lastSuccess());</span>
<span class="fc" id="L1105">            return false;</span>
        }
        else
        {
<span class="fc" id="L1109">            executeActions(match);</span>
<span class="fc" id="L1110">            return true;</span>
        }
    }

    public void validate ()
    {
<span class="fc" id="L1116">        requireRoot();</span>
<span class="fc" id="L1117">        checkForUndefinedRules();</span>
<span class="fc" id="L1118">        checkForUndeclaredPasses();</span>
<span class="fc" id="L1119">    }</span>

    private void requireRoot ()
    {
<span class="pc bpc" id="L1123" title="1 of 2 branches missed.">        if (rules.containsKey(root) == false)</span>
        {
<span class="nc" id="L1125">            throw new IllegalStateException(&quot;No Root Rule&quot;);</span>
        }
<span class="fc" id="L1127">    }</span>

    /**
     * This method reports any rules that are used, but not defined in the schema.
     */
    private void checkForUndefinedRules ()
    {
<span class="fc" id="L1134">        final Set&lt;String&gt; definedRules = rules.keySet();</span>
<span class="fc" id="L1135">        final Set&lt;String&gt; temp = new HashSet&lt;&gt;(usedRules);</span>
<span class="fc" id="L1136">        temp.removeAll(definedRules);</span>
<span class="fc" id="L1137">        final List&lt;String&gt; undefinedRules = new ArrayList&lt;&gt;(temp);</span>

<span class="pc bpc" id="L1139" title="1 of 2 branches missed.">        if (undefinedRules.isEmpty() == false)</span>
        {
<span class="nc" id="L1141">            final String names = SList.copyOf(undefinedRules.stream().map(name -&gt; new SAtom(name))).toString();</span>
<span class="nc" id="L1142">            final String message = &quot;Undefined Rules Detected: &quot; + names;</span>
<span class="nc" id="L1143">            throw new IllegalStateException(message);</span>
        }
<span class="fc" id="L1145">    }</span>

    private void checkForUndeclaredPasses ()
    {
        /**
         * Check for before-actions that are not apart of a declared pass.
         */
<span class="fc bfc" id="L1152" title="All 2 branches covered.">        for (String pass : beforeActions.keySet())</span>
        {
<span class="fc bfc" id="L1154" title="All 2 branches covered.">            if (passes.contains(pass) == false)</span>
            {
<span class="fc" id="L1156">                throw new IllegalStateException(String.format(&quot;Undeclared Pass: %s&quot;, pass));</span>
            }
<span class="fc" id="L1158">        }</span>

        /**
         * Check for after-actions that are not apart of a declared pass.
         */
<span class="fc bfc" id="L1163" title="All 2 branches covered.">        for (String pass : afterActions.keySet())</span>
        {
<span class="fc bfc" id="L1165" title="All 2 branches covered.">            if (passes.contains(pass) == false)</span>
            {
<span class="fc" id="L1167">                throw new IllegalStateException(String.format(&quot;Undeclared Pass: %s&quot;, pass));</span>
            }
<span class="fc" id="L1169">        }</span>
<span class="fc" id="L1170">    }</span>

    /**
     * On successful matches, this method transverses the match-tree
     * in multiple &quot;translation passes&quot; executing user-defined actions.
     *
     * @param tree describes a successful match attempt.
     */
    private void executeActions (final MatchNode tree)
    {
<span class="fc" id="L1180">        passes.forEach(pass -&gt; executeActions(pass, tree));</span>
<span class="fc" id="L1181">    }</span>

    private void executeActions (final String pass,
                                 final MatchNode node)
    {
<span class="fc bfc" id="L1186" title="All 4 branches covered.">        if (beforeActions.containsKey(pass) &amp;&amp; beforeActions.get(pass).containsKey(node.rule().name()))</span>
        {
<span class="fc" id="L1188">            final List&lt;Consumer&lt;Sexpr&gt;&gt; actions = beforeActions.get(pass).get(node.rule().name());</span>
<span class="fc" id="L1189">            actions.forEach(action -&gt; action.accept(node.node()));</span>
        }

<span class="fc" id="L1192">        node.children().forEach(child -&gt; executeActions(pass, child));</span>

<span class="fc bfc" id="L1194" title="All 4 branches covered.">        if (afterActions.containsKey(pass) &amp;&amp; afterActions.get(pass).containsKey(node.rule().name()))</span>
        {
<span class="fc" id="L1196">            final List&lt;Consumer&lt;Sexpr&gt;&gt; actions = afterActions.get(pass).get(node.rule().name());</span>
<span class="fc" id="L1197">            actions.forEach(action -&gt; action.accept(node.node()));</span>
        }
<span class="fc" id="L1199">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>