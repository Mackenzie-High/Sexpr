<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SchemaBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Sexpr&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.sexpr.schema</a> &gt; <span class="el_source">SchemaBuilder.java</span></div><h1>SchemaBuilder.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.sexpr.schema;

import com.mackenziehigh.sexpr.SAtom;
import com.mackenziehigh.sexpr.Sexpr;
import java.util.Arrays;
import java.util.Objects;
import java.util.Set;
import java.util.TreeSet;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.regex.Pattern;

/**
 * Use this class to create Schema objects based on a Sexpr grammar.
 */
public interface SchemaBuilder
{
    /**
     * This interface defines methods for selecting
     * the type of rule being defined.
     */
    public interface RuleBuilder
    {
        /**
         * This method defines this rule as the root rule in the schema.
         *
         * @return this.
         */
        public RuleBuilder root ();

        /**
         * This method defines a rule that matches a SAtom only.
         *
         * @return a builder for the rule.
         */
        public Leaf leaf ();

        /**
         * This method defines a rule that consists of a series of options,
         * such that all of the options must successfully match.
         *
         * &lt;p&gt;
         * The options will be tried from first to last.
         * &lt;/p&gt;
         *
         * @return a builder for the rule.
         */
        public Conjunction all ();

        /**
         * This method defines a rule that consists of a series of options,
         * such that exactly one of the options must successfully match.
         *
         * &lt;p&gt;
         * The options will be tried from first to last.
         * &lt;/p&gt;
         *
         * @return a builder for the rule.
         */
        public Disjunction choice ();

        /**
         * This method defines a rule that consists of a series of options,
         * such that none of the options must successfully match.
         *
         * &lt;p&gt;
         * The options will be tried from first to last.
         * &lt;/p&gt;
         *
         * @return a builder for the rule.
         */
        public Negation none ();

        /**
         * This method defines a rule that matches a SList.
         *
         * &lt;p&gt;
         * The rule requires a fixed-length prefix
         * and an optional variable-length suffix.
         * &lt;/p&gt;
         *
         * @return a builder for the rule.
         */
        public SequencePrefix list ();

        /**
         * This method defines a rule that matches any Sexpr.
         *
         * @return a builder for the rule.
         */
        public Any any ();
    }

    /**
     * This method defines methods shared by all types of rules.
     *
     * @param &lt;T&gt; is the specific type of rule.
     */
    public interface Rule&lt;T extends Rule&lt;T&gt;&gt;
    {
        /**
         * This method adds an action to execute upon
         * successfully matching this rule.
         *
         * &lt;p&gt;
         * Multiple actions may be defined by repeated
         * calls to this method.
         * &lt;/p&gt;
         *
         * @param action is the action to add.
         * @return this.
         */
        public T before (Consumer&lt;? extends Sexpr&gt; action);

        /**
         * This method adds an action to execute upon
         * successfully matching this rule.
         *
         * &lt;p&gt;
         * Multiple actions may be defined by repeated
         * calls to this method.
         * &lt;/p&gt;
         *
         * @param action is the action to add.
         * @return this.
         */
        public T after (Consumer&lt;? extends Sexpr&gt; action);
    }

    /**
     * An instance of this interface configures a rule
     * that can only be used to match a SAtom.
     */
    public interface Leaf
            extends Rule&lt;Leaf&gt;
    {
        /**
         * This method specifies that the SAtom must
         * match a given condition.
         *
         * @param condition must return for this rule to match.
         * @return this.
         */
        public Leaf require (Predicate&lt;SAtom&gt; condition);

        /**
         * This method specifies that this rule will
         * only successfully match atoms that have
         * a boolean representation.
         *
         * @return this.
         */
        public default Leaf requireBoolean ()
        {
<span class="nc" id="L155">            require(x -&gt; x.asBoolean().isPresent());</span>
<span class="nc" id="L156">            return this;</span>
        }

        /**
         * This method specifies that this rule will
         * only successfully match atoms that have
         * a character representation.
         *
         * @return this.
         */
        public default Leaf requireChar ()
        {
<span class="nc" id="L168">            require(x -&gt; x.asChar().isPresent());</span>
<span class="nc" id="L169">            return this;</span>
        }

        /**
         * This method specifies that this rule will
         * only successfully match atoms that have
         * an integer representation.
         *
         * @return this.
         */
        public default Leaf requireByte ()
        {
<span class="nc" id="L181">            require(x -&gt; x.asByte().isPresent());</span>
<span class="nc" id="L182">            return this;</span>
        }

        /**
         * This method specifies that this rule will
         * only successfully match atoms that have
         * an integer representation.
         *
         * @return this.
         */
        public default Leaf requireShort ()
        {
<span class="nc" id="L194">            require(x -&gt; x.asShort().isPresent());</span>
<span class="nc" id="L195">            return this;</span>
        }

        /**
         * This method specifies that this rule will
         * only successfully match atoms that have
         * an integer representation.
         *
         * @return this.
         */
        public default Leaf requireInt ()
        {
<span class="nc" id="L207">            require(x -&gt; x.asInt().isPresent());</span>
<span class="nc" id="L208">            return this;</span>

        }

        /**
         * This method specifies that this rule will
         * only successfully match atoms that have
         * an integer representation.
         *
         * @return this.
         */
        public default Leaf requireLong ()
        {
<span class="nc" id="L221">            require(x -&gt; x.asLong().isPresent());</span>
<span class="nc" id="L222">            return this;</span>
        }

        /**
         * This method specifies that this rule will
         * only successfully match atoms that have
         * a floating-point representation.
         *
         * @return this.
         */
        public default Leaf requireFloat ()
        {
<span class="nc" id="L234">            require(x -&gt; x.asFloat().isPresent());</span>
<span class="nc" id="L235">            return this;</span>
        }

        /**
         * This method specifies that this rule will
         * only successfully match atoms that have
         * a floating-point representation.
         *
         * @return this.
         */
        public default Leaf requireDouble ()
        {
<span class="nc" id="L247">            require(x -&gt; x.asDouble().isPresent());</span>
<span class="nc" id="L248">            return this;</span>
        }

        /**
         * This method specifies that this rule will
         * only successfully match atoms that have
         * a real Class representation.
         *
         * @return this.
         */
        public default Leaf requireClass ()
        {
<span class="nc" id="L260">            require(x -&gt; x.asClass().isPresent());</span>
<span class="nc" id="L261">            return this;</span>
        }

        /**
         * This method specifies that this rule will
         * only match when the content() of the atom
         * matches the given regular-expression.
         *
         * @param pattern is the regular-expression.
         * @return this.
         */
        public default Leaf requireMatch (String pattern)
        {
<span class="nc" id="L274">            return requireMatch(Pattern.compile(pattern));</span>
        }

        /**
         * This method specifies that this rule will
         * only match when the content() of the atom
         * matches the given regular-expression.
         *
         * @param pattern is the regular-expression.
         * @return this.
         */
        public default Leaf requireMatch (Pattern pattern)
        {
<span class="nc" id="L287">            require(x -&gt; pattern.matcher(x.content()).matches());</span>
<span class="nc" id="L288">            return this;</span>
        }

        /**
         * This method specifies that this rule will only
         * successfully match when the content() of the atom
         * is one of the given values.
         *
         * @param values are the given values.
         * @return this.
         */
        public default Leaf require (String... values)
        {
<span class="nc" id="L301">            Arrays.asList(values).forEach(x -&gt; Objects.requireNonNull(x));</span>
<span class="nc" id="L302">            final Set&lt;String&gt; set = new TreeSet&lt;&gt;();</span>
<span class="nc" id="L303">            set.addAll(Arrays.asList(values));</span>
<span class="nc" id="L304">            require(x -&gt; set.contains(x.content()));</span>
<span class="nc" id="L305">            return this;</span>
        }
    }

    /**
     * An instance of this class configures a rule
     * that consists of a conjunction of other rules.
     */
    public interface Conjunction
            extends Rule&lt;Conjunction&gt;
    {
        /**
         * This method specifies the rules that all
         * must match in order for this rule to match.
         *
         * @param names are the names of rules.
         * @return this.
         */
        public Conjunction of (String... names);
    }

    /**
     * An instance of this class configures a rule
     * that consists of a disjunction of other rules.
     */
    public interface Disjunction
            extends Rule&lt;Disjunction&gt;
    {
        /**
         * This method specifies the rules,
         * one of which must match in order
         * for this rule to match.
         *
         * @param names are the names of rules.
         * @return this.
         */
        public Disjunction of (String... names);
    }

    /**
     * An instance of this class configures a rule that
     * consists of a negated conjunction of other rules.
     */
    public interface Negation
            extends Rule&lt;Negation&gt;
    {
        /**
         * This method specifies the rules that cannot
         * match in order for this rule to match.
         *
         * @param names are the names of rules.
         * @return this.
         */
        public Negation of (String... names);
    }

    /**
     * An instance of this class configures the prefix part
     * of a sequence rule that matches the front of a SList.
     */
    public interface SequencePrefix
            extends Rule&lt;SequencePrefix&gt;
    {
        /**
         * This method specifies that the rule will only successfully match,
         * iff the elements (E1, E2, E3, ... EN) of the SList when a series
         * of rules (R1, R2, R3, ... RN) pairwise match the elements (e.g. R1 == E1).
         *
         * @param names are the names of the rules that must match the elements.
         * @return the suffix part of the sequence rule.
         */
        public SequenceSuffix of (String... names);
    }

    /**
     * An instance of this class configures the suffix part
     * of a sequence rule that matches the tail of a SList.
     */
    public interface SequenceSuffix
            extends Rule&lt;SequenceSuffix&gt;
    {
        /**
         * This method specifies a rule that must successfully
         * match any elements beyond the fixed-length prefix
         * of the SList.
         *
         * @param name is the name of the rule.
         * @return this.
         */
        public SequenceSuffix followedBy (String name);

        /**
         * This method specifies that the length of the suffix
         * must be at least a given number of elements.
         *
         * @param count is the required minimum length.
         * @return this.
         */
        public SequenceSuffix min (int count);

        /**
         * This method specifies that the length of the suffix
         * must be at most a given number of elements.
         *
         * @param count is the required maximum length.
         * @return this.
         */
        public SequenceSuffix max (int count);
    }

    /**
     * An instance of this interfaces configures a rule
     * that will successfully match any Sexpr.
     */
    public interface Any
            extends Rule&lt;Any&gt;
    {
        // Pass
    }

    /**
     * This method adds another rule to the schema.
     *
     * @param name will be the name of the new rule.
     * @return an object that can be used to configure the new rule.
     */
    public RuleBuilder define (String name);

    /**
     * This method creates the schema described by this grammar.
     *
     * @return the schema.
     * @throws IllegalStateException if this method was already invoked.
     */
    public Schema build ();
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>