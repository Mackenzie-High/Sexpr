<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Lexer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Sexpr&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.sexpr.internal</a> &gt; <span class="el_source">Lexer.java</span></div><h1>Lexer.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.sexpr.internal;

/* The following code was generated by JFlex 1.4.3 on 8/31/18, 1:05 AM */
/**
 * This class is a scanner generated by
 * &lt;a href=&quot;http://www.jflex.de/&quot;&gt;JFlex&lt;/a&gt; 1.4.3
 * on 8/31/18, 1:05 AM from the specification file
 * &lt;tt&gt;Lexer.txt&lt;/tt&gt;
 */
final class Lexer
{

    /**
     * This character denotes the end of file
     */
    public static final int YYEOF = -1;

    /**
     * initial size of the lookahead buffer
     */
    private static final int ZZ_BUFFERSIZE = 16384;

    /**
     * lexical states
     */
    public static final int YYINITIAL = 0;

    /**
     * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
     * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
     * at the beginning of a line
     * l is of the form l = 2*k, k a non negative integer
     */
<span class="fc" id="L34">    private static final int ZZ_LEXSTATE[] =</span>
    {
        0,
        0
    };

    /**
     * Translates characters to character classes
     */
    private static final String ZZ_CMAP_PACKED
                                = &quot;\11\0\1\10\1\7\2\0\1\7\22\0\1\10\1\0\1\3\1\6&quot;
                                  + &quot;\3\0\1\2\1\11\1\5\26\0\1\1\33\0\1\4\uffa3\0&quot;;

    /**
     * Translates characters to character classes
     */
<span class="fc" id="L50">    private static final char[] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);</span>

    /**
     * Translates DFA states to action switch labels.
     */
<span class="fc" id="L55">    private static final int[] ZZ_ACTION = zzUnpackAction();</span>

    private static final String ZZ_ACTION_PACKED_0
                                = &quot;\1\0\2\1\2\2\1\3\2\4\1\5\3\0\1\6&quot;
                                  + &quot;\2\0\1\7\1\0\1\10\1\11\1\6\1\7&quot;;

    private static int[] zzUnpackAction ()
    {
<span class="fc" id="L63">        int[] result = new int[21];</span>
<span class="fc" id="L64">        int offset = 0;</span>
<span class="fc" id="L65">        offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);</span>
<span class="fc" id="L66">        return result;</span>
    }

    private static int zzUnpackAction (String packed,
                                       int offset,
                                       int[] result)
    {
<span class="fc" id="L73">        int i = 0;</span>
        /* index in packed string  */
<span class="fc" id="L75">        int j = offset;</span>
        /* index in unpacked array */
<span class="fc" id="L77">        int l = packed.length();</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">        while (i &lt; l)</span>
        {
<span class="fc" id="L80">            int count = packed.charAt(i++);</span>
<span class="fc" id="L81">            int value = packed.charAt(i++);</span>
            do
            {
<span class="fc" id="L84">                result[j++] = value;</span>
            }
<span class="fc bfc" id="L86" title="All 2 branches covered.">            while (--count &gt; 0);</span>
<span class="fc" id="L87">        }</span>
<span class="fc" id="L88">        return j;</span>
    }

    /**
     * Translates a state to a row index in the transition table
     */
<span class="fc" id="L94">    private static final int[] ZZ_ROWMAP = zzUnpackRowMap();</span>

    private static final String ZZ_ROWMAP_PACKED_0
                                = &quot;\0\0\0\12\0\24\0\36\0\50\0\62\0\74\0\62&quot;
                                  + &quot;\0\62\0\106\0\120\0\36\0\62\0\132\0\50\0\62&quot;
                                  + &quot;\0\144\0\62\0\62\0\36\0\50&quot;;

    private static int[] zzUnpackRowMap ()
    {
<span class="fc" id="L103">        int[] result = new int[21];</span>
<span class="fc" id="L104">        int offset = 0;</span>
<span class="fc" id="L105">        offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);</span>
<span class="fc" id="L106">        return result;</span>
    }

    private static int zzUnpackRowMap (String packed,
                                       int offset,
                                       int[] result)
    {
<span class="fc" id="L113">        int i = 0;</span>
        /* index in packed string  */
<span class="fc" id="L115">        int j = offset;</span>
        /* index in unpacked array */
<span class="fc" id="L117">        int l = packed.length();</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">        while (i &lt; l)</span>
        {
<span class="fc" id="L120">            int high = packed.charAt(i++) &lt;&lt; 16;</span>
<span class="fc" id="L121">            result[j++] = high | packed.charAt(i++);</span>
<span class="fc" id="L122">        }</span>
<span class="fc" id="L123">        return j;</span>
    }

    /**
     * The transition table of the DFA
     */
<span class="fc" id="L129">    private static final int[] ZZ_TRANS = zzUnpackTrans();</span>

    private static final String ZZ_TRANS_PACKED_0
                                = &quot;\1\2\1\3\1\4\1\5\1\2\1\6\1\7\2\10&quot;
                                  + &quot;\1\11\2\2\2\0\1\2\5\0\2\2\1\12\1\13&quot;
                                  + &quot;\1\2\5\0\2\14\1\15\1\14\1\16\5\14\3\17&quot;
                                  + &quot;\1\20\1\21\5\17\12\0\7\7\1\0\2\7\2\12&quot;
                                  + &quot;\1\22\7\12\3\13\1\23\6\13\2\14\1\24\1\14&quot;
                                  + &quot;\1\16\5\14\3\17\1\25\1\21\5\17&quot;;

    private static int[] zzUnpackTrans ()
    {
<span class="fc" id="L141">        int[] result = new int[110];</span>
<span class="fc" id="L142">        int offset = 0;</span>
<span class="fc" id="L143">        offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);</span>
<span class="fc" id="L144">        return result;</span>
    }

    private static int zzUnpackTrans (String packed,
                                      int offset,
                                      int[] result)
    {
<span class="fc" id="L151">        int i = 0;</span>
        /* index in packed string  */
<span class="fc" id="L153">        int j = offset;</span>
        /* index in unpacked array */
<span class="fc" id="L155">        int l = packed.length();</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">        while (i &lt; l)</span>
        {
<span class="fc" id="L158">            int count = packed.charAt(i++);</span>
<span class="fc" id="L159">            int value = packed.charAt(i++);</span>
<span class="fc" id="L160">            value--;</span>
            do
            {
<span class="fc" id="L163">                result[j++] = value;</span>
            }
<span class="fc bfc" id="L165" title="All 2 branches covered.">            while (--count &gt; 0);</span>
<span class="fc" id="L166">        }</span>
<span class="fc" id="L167">        return j;</span>
    }


    /* error codes */
    private static final int ZZ_UNKNOWN_ERROR = 0;

    private static final int ZZ_NO_MATCH = 1;

    private static final int ZZ_PUSHBACK_2BIG = 2;

    /* error messages for the codes above */
<span class="fc" id="L179">    private static final String ZZ_ERROR_MSG[] =</span>
    {
        &quot;Unkown internal scanner error&quot;,
        &quot;Error: could not match input&quot;,
        &quot;Error: pushback value was too large&quot;
    };

    /**
     * ZZ_ATTRIBUTE[aState] contains the attributes of state &lt;code&gt;aState&lt;/code&gt;
     */
<span class="fc" id="L189">    private static final int[] ZZ_ATTRIBUTE = zzUnpackAttribute();</span>

    private static final String ZZ_ATTRIBUTE_PACKED_0
                                = &quot;\1\0\4\1\1\11\1\1\2\11\3\0\1\11\2\0&quot;
                                  + &quot;\1\11\1\0\2\11\2\1&quot;;

    private static int[] zzUnpackAttribute ()
    {
<span class="fc" id="L197">        int[] result = new int[21];</span>
<span class="fc" id="L198">        int offset = 0;</span>
<span class="fc" id="L199">        offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);</span>
<span class="fc" id="L200">        return result;</span>
    }

    private static int zzUnpackAttribute (String packed,
                                          int offset,
                                          int[] result)
    {
<span class="fc" id="L207">        int i = 0;</span>
        /* index in packed string  */
<span class="fc" id="L209">        int j = offset;</span>
        /* index in unpacked array */
<span class="fc" id="L211">        int l = packed.length();</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">        while (i &lt; l)</span>
        {
<span class="fc" id="L214">            int count = packed.charAt(i++);</span>
<span class="fc" id="L215">            int value = packed.charAt(i++);</span>
            do
            {
<span class="fc" id="L218">                result[j++] = value;</span>
            }
<span class="fc bfc" id="L220" title="All 2 branches covered.">            while (--count &gt; 0);</span>
<span class="fc" id="L221">        }</span>
<span class="fc" id="L222">        return j;</span>
    }

    /**
     * the input device
     */
    private java.io.Reader zzReader;

    /**
     * the current state of the DFA
     */
    private int zzState;

    /**
     * the current lexical state
     */
<span class="fc" id="L238">    private int zzLexicalState = YYINITIAL;</span>

    /**
     * this buffer contains the current text to be matched and is
     * the source of the yytext() string
     */
<span class="fc" id="L244">    private char zzBuffer[] = new char[ZZ_BUFFERSIZE];</span>

    /**
     * the textposition at the last accepting state
     */
    private int zzMarkedPos;

    /**
     * the current text position in the buffer
     */
    private int zzCurrentPos;

    /**
     * startRead marks the beginning of the yytext() string in the buffer
     */
    private int zzStartRead;

    /**
     * endRead marks the last character in the buffer, that has been read
     * from input
     */
    private int zzEndRead;

    /**
     * number of newlines encountered up to the start of the matched text
     */
    private int yyline;

    /**
     * the number of characters up to the start of the matched text
     */
    private int yychar;

    /**
     * the number of characters from the last newline up to the start of the
     * matched text
     */
    private int yycolumn;

    /**
     * zzAtBOL == true &lt;=&gt; the scanner is currently at the beginning of a line
     */
<span class="fc" id="L286">    private boolean zzAtBOL = true;</span>

    /**
     * zzAtEOF == true &lt;=&gt; the scanner is at the EOF
     */
    private boolean zzAtEOF;

    /**
     * denotes if the user-EOF-code has already been executed
     */
    private boolean zzEOFDone;

    /* user code: */
<span class="fc" id="L299">    final com.mackenziehigh.sexpr.util.BuilderStack stack = new com.mackenziehigh.sexpr.util.BuilderStack();</span>

    /**
     * Creates a new scanner
     * There is also a java.io.InputStream version of this constructor.
     *
     * @param in the java.io.Reader to read input from.
     */
    Lexer (java.io.Reader in)
<span class="fc" id="L308">    {</span>
<span class="fc" id="L309">        this.zzReader = in;</span>
<span class="fc" id="L310">    }</span>

    /**
     * Creates a new scanner.
     * There is also java.io.Reader version of this constructor.
     *
     * @param in the java.io.Inputstream to read input from.
     */
    Lexer (java.io.InputStream in)
    {
<span class="nc" id="L320">        this(new java.io.InputStreamReader(in));</span>
<span class="nc" id="L321">    }</span>

    /**
     * Unpacks the compressed character translation table.
     *
     * @param packed the packed character translation table
     * @return the unpacked character translation table
     */
    private static char[] zzUnpackCMap (String packed)
    {
<span class="fc" id="L331">        char[] map = new char[0x10000];</span>
<span class="fc" id="L332">        int i = 0;</span>
        /* index in packed string  */
<span class="fc" id="L334">        int j = 0;</span>
        /* index in unpacked array */
<span class="fc bfc" id="L336" title="All 2 branches covered.">        while (i &lt; 38)</span>
        {
<span class="fc" id="L338">            int count = packed.charAt(i++);</span>
<span class="fc" id="L339">            char value = packed.charAt(i++);</span>
            do
            {
<span class="fc" id="L342">                map[j++] = value;</span>
            }
<span class="fc bfc" id="L344" title="All 2 branches covered.">            while (--count &gt; 0);</span>
<span class="fc" id="L345">        }</span>
<span class="fc" id="L346">        return map;</span>
    }

    /**
     * Refills the input buffer.
     *
     * @return      &lt;code&gt;false&lt;/code&gt;, iff there was new input.
     *
     * @exception java.io.IOException if any I/O-Error occurs
     */
    private boolean zzRefill ()
            throws java.io.IOException
    {

        /* first: make room (if you can) */
<span class="fc bfc" id="L361" title="All 2 branches covered.">        if (zzStartRead &gt; 0)</span>
        {
<span class="fc" id="L363">            System.arraycopy(zzBuffer, zzStartRead,</span>
                             zzBuffer, 0,
                             zzEndRead - zzStartRead);

            /* translate stored positions */
<span class="fc" id="L368">            zzEndRead -= zzStartRead;</span>
<span class="fc" id="L369">            zzCurrentPos -= zzStartRead;</span>
<span class="fc" id="L370">            zzMarkedPos -= zzStartRead;</span>
<span class="fc" id="L371">            zzStartRead = 0;</span>
        }

        /* is the buffer big enough? */
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">        if (zzCurrentPos &gt;= zzBuffer.length)</span>
        {
            /* if not: blow it up */
<span class="nc" id="L378">            char newBuffer[] = new char[zzCurrentPos * 2];</span>
<span class="nc" id="L379">            System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);</span>
<span class="nc" id="L380">            zzBuffer = newBuffer;</span>
        }

        /* finally: fill the buffer with new input */
<span class="fc" id="L384">        int numRead = zzReader.read(zzBuffer, zzEndRead,</span>
                                    zzBuffer.length - zzEndRead);

<span class="fc bfc" id="L387" title="All 2 branches covered.">        if (numRead &gt; 0)</span>
        {
<span class="fc" id="L389">            zzEndRead += numRead;</span>
<span class="fc" id="L390">            return false;</span>
        }
        // unlikely but not impossible: read 0 characters, but not at end of stream
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">        if (numRead == 0)</span>
        {
<span class="nc" id="L395">            int c = zzReader.read();</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">            if (c == -1)</span>
            {
<span class="nc" id="L398">                return true;</span>
            }
            else
            {
<span class="nc" id="L402">                zzBuffer[zzEndRead++] = (char) c;</span>
<span class="nc" id="L403">                return false;</span>
            }
        }

        // numRead &lt; 0
<span class="fc" id="L408">        return true;</span>
    }

    /**
     * Closes the input stream.
     */
    public final void yyclose ()
            throws java.io.IOException
    {
<span class="nc" id="L417">        zzAtEOF = true;</span>
        /* indicate end of file */
<span class="nc" id="L419">        zzEndRead = zzStartRead;</span>
        /* invalidate buffer    */

<span class="nc bnc" id="L422" title="All 2 branches missed.">        if (zzReader != null)</span>
        {
<span class="nc" id="L424">            zzReader.close();</span>
        }
<span class="nc" id="L426">    }</span>

    /**
     * Resets the scanner to read from a new input stream.
     * Does not close the old reader.
     *
     * All internal variables are reset, the old input stream
     * &lt;b&gt;cannot&lt;/b&gt; be reused (internal buffer is discarded and lost).
     * Lexical state is set to &lt;tt&gt;ZZ_INITIAL&lt;/tt&gt;.
     *
     * @param reader the new input stream
     */
    public final void yyreset (java.io.Reader reader)
    {
<span class="nc" id="L440">        zzReader = reader;</span>
<span class="nc" id="L441">        zzAtBOL = true;</span>
<span class="nc" id="L442">        zzAtEOF = false;</span>
<span class="nc" id="L443">        zzEOFDone = false;</span>
<span class="nc" id="L444">        zzEndRead = zzStartRead = 0;</span>
<span class="nc" id="L445">        zzCurrentPos = zzMarkedPos = 0;</span>
<span class="nc" id="L446">        yyline = yychar = yycolumn = 0;</span>
<span class="nc" id="L447">        zzLexicalState = YYINITIAL;</span>
<span class="nc" id="L448">    }</span>

    /**
     * Returns the current lexical state.
     */
    public final int yystate ()
    {
<span class="nc" id="L455">        return zzLexicalState;</span>
    }

    /**
     * Enters a new lexical state
     *
     * @param newState the new lexical state
     */
    public final void yybegin (int newState)
    {
<span class="nc" id="L465">        zzLexicalState = newState;</span>
<span class="nc" id="L466">    }</span>

    /**
     * Returns the text matched by the current regular expression.
     */
    public final String yytext ()
    {
<span class="fc" id="L473">        return new String(zzBuffer, zzStartRead, zzMarkedPos - zzStartRead);</span>
    }

    /**
     * Returns the character at position &lt;tt&gt;pos&lt;/tt&gt; from the
     * matched text.
     *
     * It is equivalent to yytext().charAt(pos), but faster
     *
     * @param pos the position of the character to fetch.
     * A value from 0 to yylength()-1.
     *
     * @return the character at position pos
     */
    public final char yycharat (int pos)
    {
<span class="nc" id="L489">        return zzBuffer[zzStartRead + pos];</span>
    }

    /**
     * Returns the length of the matched text region.
     */
    public final int yylength ()
    {
<span class="nc" id="L497">        return zzMarkedPos - zzStartRead;</span>
    }

    /**
     * Reports an error that occured while scanning.
     *
     * In a wellformed scanner (no or only correct usage of
     * yypushback(int) and a match-all fallback rule) this method
     * will only be called with things that &quot;Can't Possibly Happen&quot;.
     * If this method is called, something is seriously wrong
     * (e.g. a JFlex bug producing a faulty scanner etc.).
     *
     * Usual syntax/scanner level error handling should be done
     * in error fallback rules.
     *
     * @param errorCode the code of the errormessage to display
     */
    private void zzScanError (int errorCode)
    {
        String message;
        try
        {
<span class="nc" id="L519">            message = ZZ_ERROR_MSG[errorCode];</span>
        }
<span class="nc" id="L521">        catch (ArrayIndexOutOfBoundsException e)</span>
        {
<span class="nc" id="L523">            message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];</span>
<span class="nc" id="L524">        }</span>

<span class="nc" id="L526">        throw new Error(message);</span>
    }

    /**
     * Pushes the specified amount of characters back into the input stream.
     *
     * They will be read again by then next call of the scanning method
     *
     * @param number the number of characters to be read again.
     * This number must not be greater than yylength()!
     */
    public void yypushback (int number)
    {
<span class="nc bnc" id="L539" title="All 2 branches missed.">        if (number &gt; yylength())</span>
        {
<span class="nc" id="L541">            zzScanError(ZZ_PUSHBACK_2BIG);</span>
        }

<span class="nc" id="L544">        zzMarkedPos -= number;</span>
<span class="nc" id="L545">    }</span>

    /**
     * Resumes scanning until the next regular expression is matched,
     * the end of input is encountered or an I/O-Error occurs.
     *
     * @return the next token
     * @exception java.io.IOException if any I/O-Error occurs
     */
    public int yylex ()
            throws java.io.IOException
    {
        int zzInput;
        int zzAction;

        // cached fields:
        int zzCurrentPosL;
        int zzMarkedPosL;
<span class="fc" id="L563">        int zzEndReadL = zzEndRead;</span>
<span class="fc" id="L564">        char[] zzBufferL = zzBuffer;</span>
<span class="fc" id="L565">        char[] zzCMapL = ZZ_CMAP;</span>

<span class="fc" id="L567">        int[] zzTransL = ZZ_TRANS;</span>
<span class="fc" id="L568">        int[] zzRowMapL = ZZ_ROWMAP;</span>
<span class="fc" id="L569">        int[] zzAttrL = ZZ_ATTRIBUTE;</span>

        while (true)
        {
<span class="fc" id="L573">            zzMarkedPosL = zzMarkedPos;</span>

<span class="fc" id="L575">            boolean zzR = false;</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">            for (zzCurrentPosL = zzStartRead; zzCurrentPosL &lt; zzMarkedPosL;</span>
<span class="fc" id="L577">                 zzCurrentPosL++)</span>
            {
<span class="pc bpc" id="L579" title="2 of 4 branches missed.">                switch (zzBufferL[zzCurrentPosL])</span>
                {
                    case '\u000B':
                    case '\u000C':
                    case '\u0085':
                    case '\u2028':
                    case '\u2029':
<span class="nc" id="L586">                        yyline++;</span>
<span class="nc" id="L587">                        yycolumn = 0;</span>
<span class="nc" id="L588">                        zzR = false;</span>
<span class="nc" id="L589">                        break;</span>
                    case '\r':
<span class="nc" id="L591">                        yyline++;</span>
<span class="nc" id="L592">                        yycolumn = 0;</span>
<span class="nc" id="L593">                        zzR = true;</span>
<span class="nc" id="L594">                        break;</span>
                    case '\n':
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">                        if (zzR)</span>
                        {
<span class="nc" id="L598">                            zzR = false;</span>
                        }
                        else
                        {
<span class="fc" id="L602">                            yyline++;</span>
<span class="fc" id="L603">                            yycolumn = 0;</span>
                        }
<span class="fc" id="L605">                        break;</span>
                    default:
<span class="fc" id="L607">                        zzR = false;</span>
<span class="fc" id="L608">                        yycolumn++;</span>
                }
            }

<span class="pc bpc" id="L612" title="1 of 2 branches missed.">            if (zzR)</span>
            {
                // peek one character ahead if it is \n (if we have counted one line too much)
                boolean zzPeek;
<span class="nc bnc" id="L616" title="All 2 branches missed.">                if (zzMarkedPosL &lt; zzEndReadL)</span>
                {
<span class="nc bnc" id="L618" title="All 2 branches missed.">                    zzPeek = zzBufferL[zzMarkedPosL] == '\n';</span>
                }
<span class="nc bnc" id="L620" title="All 2 branches missed.">                else if (zzAtEOF)</span>
                {
<span class="nc" id="L622">                    zzPeek = false;</span>
                }
                else
                {
<span class="nc" id="L626">                    boolean eof = zzRefill();</span>
<span class="nc" id="L627">                    zzEndReadL = zzEndRead;</span>
<span class="nc" id="L628">                    zzMarkedPosL = zzMarkedPos;</span>
<span class="nc" id="L629">                    zzBufferL = zzBuffer;</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">                    if (eof)</span>
                    {
<span class="nc" id="L632">                        zzPeek = false;</span>
                    }
                    else
                    {
<span class="nc bnc" id="L636" title="All 2 branches missed.">                        zzPeek = zzBufferL[zzMarkedPosL] == '\n';</span>
                    }
                }
<span class="nc bnc" id="L639" title="All 2 branches missed.">                if (zzPeek)</span>
                {
<span class="nc" id="L641">                    yyline--;</span>
                }
            }
<span class="fc" id="L644">            zzAction = -1;</span>

<span class="fc" id="L646">            zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;</span>

<span class="fc" id="L648">            zzState = ZZ_LEXSTATE[zzLexicalState];</span>

zzForAction:
            {
                while (true)
                {

<span class="fc bfc" id="L655" title="All 2 branches covered.">                    if (zzCurrentPosL &lt; zzEndReadL)</span>
                    {
<span class="fc" id="L657">                        zzInput = zzBufferL[zzCurrentPosL++];</span>
                    }
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">                    else if (zzAtEOF)</span>
                    {
<span class="nc" id="L661">                        zzInput = YYEOF;</span>
<span class="nc" id="L662">                        break zzForAction;</span>
                    }
                    else
                    {
                        // store back cached positions
<span class="fc" id="L667">                        zzCurrentPos = zzCurrentPosL;</span>
<span class="fc" id="L668">                        zzMarkedPos = zzMarkedPosL;</span>
<span class="fc" id="L669">                        boolean eof = zzRefill();</span>
                        // get translated positions and possibly new buffer
<span class="fc" id="L671">                        zzCurrentPosL = zzCurrentPos;</span>
<span class="fc" id="L672">                        zzMarkedPosL = zzMarkedPos;</span>
<span class="fc" id="L673">                        zzBufferL = zzBuffer;</span>
<span class="fc" id="L674">                        zzEndReadL = zzEndRead;</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">                        if (eof)</span>
                        {
<span class="fc" id="L677">                            zzInput = YYEOF;</span>
<span class="fc" id="L678">                            break zzForAction;</span>
                        }
                        else
                        {
<span class="fc" id="L682">                            zzInput = zzBufferL[zzCurrentPosL++];</span>
                        }
                    }
<span class="fc" id="L685">                    int zzNext = zzTransL[zzRowMapL[zzState] + zzCMapL[zzInput]];</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">                    if (zzNext == -1)</span>
                    {
<span class="fc" id="L688">                        break zzForAction;</span>
                    }
<span class="fc" id="L690">                    zzState = zzNext;</span>

<span class="fc" id="L692">                    int zzAttributes = zzAttrL[zzState];</span>
<span class="fc bfc" id="L693" title="All 2 branches covered.">                    if ((zzAttributes &amp; 1) == 1)</span>
                    {
<span class="fc" id="L695">                        zzAction = zzState;</span>
<span class="fc" id="L696">                        zzMarkedPosL = zzCurrentPosL;</span>
<span class="fc bfc" id="L697" title="All 2 branches covered.">                        if ((zzAttributes &amp; 8) == 8)</span>
                        {
<span class="fc" id="L699">                            break zzForAction;</span>
                        }
                    }

<span class="fc" id="L703">                }</span>
            }

            // store back cached position
<span class="fc" id="L707">            zzMarkedPos = zzMarkedPosL;</span>

<span class="pc bpc" id="L709" title="9 of 20 branches missed.">            switch (zzAction &lt; 0 ? zzAction : ZZ_ACTION[zzAction])</span>
            {
                case 6:
                {
<span class="fc" id="L713">                    LexerHelpers.pushAtomForm3(stack, yytext(), yyline, yycolumn);</span>
                }
                case 10:
<span class="fc" id="L716">                    break;</span>
                case 7:
                {
<span class="fc" id="L719">                    LexerHelpers.pushAtomForm4(stack, yytext(), yyline, yycolumn);</span>
                }
                case 11:
<span class="fc" id="L722">                    break;</span>
                case 4:
                { // IGNORE
                }
                case 12:
<span class="fc" id="L727">                    break;</span>
                case 1:
                {
<span class="fc" id="L730">                    LexerHelpers.pushAtomForm5(stack, yytext(), yyline, yycolumn);</span>
                }
                case 13:
<span class="fc" id="L733">                    break;</span>
                case 8:
                {
<span class="fc" id="L736">                    LexerHelpers.pushAtomForm1(stack, yytext(), yyline, yycolumn);</span>
                }
                case 14:
<span class="fc" id="L739">                    break;</span>
                case 3:
                {
<span class="fc" id="L742">                    stack.end();</span>
                }
                case 15:
<span class="fc" id="L745">                    break;</span>
                case 9:
                {
<span class="fc" id="L748">                    LexerHelpers.pushAtomForm2(stack, yytext(), yyline, yycolumn);</span>
                }
                case 16:
<span class="fc" id="L751">                    break;</span>
                case 2:
                {
<span class="nc" id="L754">                    System.out.println(&quot;DOT = &quot; + yytext() + &quot;TT&quot;);</span>
<span class="nc" id="L755">                    System.exit(1); // TODO</span>
                }
                case 17:
<span class="nc" id="L758">                    break;</span>
                case 5:
                {
<span class="fc" id="L761">                    stack.begin();</span>
                }
                case 18:
<span class="fc" id="L764">                    break;</span>
                default:
<span class="pc bpc" id="L766" title="2 of 4 branches missed.">                    if (zzInput == YYEOF &amp;&amp; zzStartRead == zzCurrentPos)</span>
                    {
<span class="fc" id="L768">                        zzAtEOF = true;</span>
<span class="fc" id="L769">                        return YYEOF;</span>
                    }
                    else
                    {
<span class="nc" id="L773">                        zzScanError(ZZ_NO_MATCH);</span>
                    }
            }
<span class="fc" id="L776">        }</span>
    }

    /**
     * Runs the scanner on input files.
     *
     * This is a standalone scanner, it will print any unmatched
     * text to System.out unchanged.
     *
     * @param argv the command line, contains the filenames to run
     * the scanner on.
     */
    public static void main (String argv[])
    {
<span class="nc bnc" id="L790" title="All 2 branches missed.">        if (argv.length == 0)</span>
        {
<span class="nc" id="L792">            System.out.println(&quot;Usage : java Lexer &lt;inputfile&gt;&quot;);</span>
        }
        else
        {
<span class="nc bnc" id="L796" title="All 2 branches missed.">            for (int i = 0; i &lt; argv.length; i++)</span>
            {
<span class="nc" id="L798">                Lexer scanner = null;</span>
                try
                {
<span class="nc" id="L801">                    scanner = new Lexer(new java.io.FileReader(argv[i]));</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">                    while (!scanner.zzAtEOF)</span>
                    {
<span class="nc" id="L804">                        scanner.yylex();</span>
                    }
                }
<span class="nc" id="L807">                catch (java.io.FileNotFoundException e)</span>
                {
<span class="nc" id="L809">                    System.out.println(&quot;File not found : \&quot;&quot; + argv[i] + &quot;\&quot;&quot;);</span>
                }
<span class="nc" id="L811">                catch (java.io.IOException e)</span>
                {
<span class="nc" id="L813">                    System.out.println(&quot;IO error scanning file \&quot;&quot; + argv[i] + &quot;\&quot;&quot;);</span>
<span class="nc" id="L814">                    System.out.println(e);</span>
                }
<span class="nc" id="L816">                catch (Exception e)</span>
                {
<span class="nc" id="L818">                    System.out.println(&quot;Unexpected exception:&quot;);</span>
<span class="nc" id="L819">                    e.printStackTrace();</span>
<span class="nc" id="L820">                }</span>
            }
        }
<span class="nc" id="L823">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>