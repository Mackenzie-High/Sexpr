<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SexprSchema.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Sexpr&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.sexpr</a> &gt; <span class="el_source">SexprSchema.java</span></div><h1>SexprSchema.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2017 Michael Mackenzie High
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.mackenziehigh.sexpr;

import com.mackenziehigh.sexpr.internal.schema.Schema;
import com.mackenziehigh.sexpr.internal.schema.SchemaParser;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.util.Objects;
import java.util.Optional;
import java.util.Scanner;
import java.util.function.Consumer;
import java.util.function.Predicate;

/**
 * An instance of this class can be used to determine
 * whether a symbolic-expression matches a schema (pattern).
 */
public final class SexprSchema
{
    /**
     * This function can be used as a default failure-handler that will
     * print the approximate location of match failures to standard-output.
     */
<span class="nc" id="L42">    public static final Consumer&lt;Optional&lt;Sexpr&gt;&gt; PRINT_FAILURE = x -&gt;</span>
    {
<span class="nc bnc" id="L44" title="All 2 branches missed.">        if (x.isPresent())</span>
        {
<span class="nc" id="L46">            System.out.println(&quot;Match Failed At &quot; + x.get().location().message());</span>
        }
        else
        {
<span class="nc" id="L50">            System.out.println(&quot;Match Totally Failed&quot;);</span>
        }
<span class="nc" id="L52">    };</span>

    private final Schema schema;

    /**
     * Sole Constructor.
     *
     * @param schema is the schema that symbolic-expressions must match.
     */
    private SexprSchema (final Schema schema)
<span class="nc" id="L62">    {</span>
<span class="nc" id="L63">        this.schema = Objects.requireNonNull(schema, &quot;schema&quot;);</span>
<span class="nc" id="L64">    }</span>

    /**
     * This method configures the matcher to use a given schema.
     *
     * @param source is a human-readable indicating where the schema is from.
     * @param schema is the schema for the matcher to use.
     * @return this.
     */
    public static Builder fromString (final String source,
                                      final String schema)
    {
<span class="nc" id="L76">        final SchemaParser parser = new SchemaParser();</span>
<span class="nc" id="L77">        final Schema pattern = parser.parse(source, schema);</span>
<span class="nc" id="L78">        return new Builder(pattern);</span>
    }

    /**
     * This method configures the matcher to use a schema from a given file.
     *
     * @param file contains the schema for the matcher to use.
     * @return this.
     * @throws java.io.IOException if the file cannot be read.
     */
    public static Builder fromFile (final File file)
            throws IOException
    {
<span class="nc" id="L91">        final String source = file.toString();</span>
<span class="nc" id="L92">        final StringBuilder content = new StringBuilder();</span>
<span class="nc" id="L93">        Files.readAllLines(file.toPath(), Charset.forName(&quot;UTF-8&quot;))</span>
<span class="nc" id="L94">                .forEach(line -&gt; content.append(line).append('\n'));</span>
<span class="nc" id="L95">        return fromString(source, content.toString());</span>
    }

    /**
     * This method configures the matcher to use a schema from a given resource.
     *
     * @param path identifies the resource that contains the schema.
     * @return this.
     * @throws java.io.IOException if the resource cannot be read.
     */
    public static Builder fromResource (final String path)
            throws IOException
    {
<span class="nc" id="L108">        final StringBuilder schema = new StringBuilder();</span>

<span class="nc" id="L110">        try (InputStream in = SexprSchema.class.getResourceAsStream(path);</span>
<span class="nc" id="L111">             BufferedInputStream bin = new BufferedInputStream(in);</span>
<span class="nc" id="L112">             Scanner scanner = new Scanner(bin))</span>
        {
<span class="nc bnc" id="L114" title="All 2 branches missed.">            while (scanner.hasNextLine())</span>
            {
<span class="nc" id="L116">                schema.append(scanner.nextLine()).append('\n');</span>
            }
<span class="nc bnc" id="L118" title="All 24 branches missed.">        }</span>
<span class="nc" id="L119">        catch (IOException | RuntimeException ex)</span>
        {
<span class="nc" id="L121">            throw ex;</span>
<span class="nc" id="L122">        }</span>

<span class="nc" id="L124">        return fromString(path, schema.toString());</span>
    }

    /**
     * This method determines whether the schema
     * matches a given symbolic-expression.
     *
     * &lt;p&gt;
     * If the match is successful, then the match-tree
     * will be traversed once for each translation-pass
     * that was defined previously. Upon encountering
     * the successful match of a rule (R) during a
     * translation-pass, the before-actions of (R)
     * will be executed, then the subordinate matches
     * will be visited and their actions will be executed,
     * and then the after-actions of (R) will be executed.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If the match is unsuccessful, then the failure-handler function
     * will be invoked passing-in the highest numbered node that
     * was successfully matched. If no node was successfully matched,
     * then an empty optional will be passed-in to the function.
     * Conceptually, the highest numbered node that is successfully
     * matched will be close to the site of failure; therefore,
     * the location of the node is useful for generating human
     * readable error-messages indication the approximate
     * location of the failure-to-match. Nodes are numbered
     * in accordance with a post-order transversal of the tree.
     * &lt;/p&gt;
     *
     * @param tree is the symbolic-expression that this schema may match.
     * @return true, iff the match was successful.
     */
    public boolean match (final Sexpr tree)
    {
<span class="nc" id="L160">        Objects.requireNonNull(tree, &quot;tree&quot;);</span>
<span class="nc" id="L161">        final boolean match = schema.match(tree);</span>
<span class="nc" id="L162">        return match;</span>
    }

    /**
     * Use an instance of this class to create a Matcher object.
     */
    public static final class Builder
    {
        /**
         * This is the instance that is being constructed.
         */
        private SexprSchema instance;

        /**
         * Sole Constructor.
         *
         * @param schema is the schema that the matcher will use.
         */
        private Builder (final Schema schema)
<span class="nc" id="L181">        {</span>
<span class="nc" id="L182">            Objects.requireNonNull(schema, &quot;schema&quot;);</span>
<span class="nc" id="L183">            this.instance = new SexprSchema(schema);</span>
<span class="nc" id="L184">        }</span>

        /**
         * Use this method to define a predicate that can be used within a schema.
         *
         * &lt;p&gt;
         * Inside of the schema, the predicate must be referenced via a 'require' rule.
         * &lt;/p&gt;
         *
         * @param name is the name that will be used to identify the predicate.
         * @param condition is the predicate itself.
         * @return this.
         * @throws IllegalArgumentException if the name already identifies a predicate.
         */
        public Builder condition (final String name,
                                  final Predicate&lt;Sexpr&gt; condition)
        {
<span class="nc" id="L201">            Objects.requireNonNull(name, &quot;name&quot;);</span>
<span class="nc" id="L202">            Objects.requireNonNull(condition, &quot;condition&quot;);</span>
<span class="nc" id="L203">            Objects.requireNonNull(instance, &quot;build() was already called.&quot;);</span>
<span class="nc" id="L204">            instance.schema.defineCondition(name, condition);</span>
<span class="nc" id="L205">            return this;</span>
        }

        /**
         * Use this method to declare another translation pass.
         *
         * &lt;p&gt;
         * Call this method multiple times in order to declare multiple passes.
         * The translation passes will occur in the order of those invocations.
         * &lt;/p&gt;
         *
         * @param name is the name of the new translation pass.
         * @return this.
         */
        public Builder pass (final String name)
        {
<span class="nc" id="L221">            Objects.requireNonNull(name, &quot;name&quot;);</span>
<span class="nc" id="L222">            instance.schema.definePass(name);</span>
<span class="nc" id="L223">            return this;</span>
        }

        /**
         * Use this method to define an action that will be executed before
         * matches of a named rule during a specific pass.
         *
         * @param pass is the name of the pass that this action applies to.
         * @param rule is the name of the rule that this action applies to.
         * @param action is the action itself.
         * @return this.
         * @throws IllegalArgumentException if the name already identifies a action.
         */
        public Builder before (final String pass,
                               final String rule,
                               final Consumer&lt;Sexpr&gt; action)
        {
<span class="nc" id="L240">            Objects.requireNonNull(pass, &quot;pass&quot;);</span>
<span class="nc" id="L241">            Objects.requireNonNull(rule, &quot;rule&quot;);</span>
<span class="nc" id="L242">            Objects.requireNonNull(action, &quot;action&quot;);</span>
<span class="nc" id="L243">            Objects.requireNonNull(instance, &quot;build() was already called.&quot;);</span>
<span class="nc" id="L244">            instance.schema.defineBeforeAction(pass, rule, action);</span>
<span class="nc" id="L245">            return this;</span>
        }

        /**
         * Use this method to define an action that will be executed after
         * matches of a named rule during a specific pass.
         *
         * @param pass is the name of the pass that this action applies to.
         * @param rule is the name of the rule that this action applies to.
         * @param action is the action itself.
         * @return this.
         * @throws IllegalArgumentException if the name already identifies a action.
         */
        public Builder after (final String pass,
                              final String rule,
                              final Consumer&lt;Sexpr&gt; action)
        {
<span class="nc" id="L262">            Objects.requireNonNull(pass, &quot;pass&quot;);</span>
<span class="nc" id="L263">            Objects.requireNonNull(rule, &quot;rule&quot;);</span>
<span class="nc" id="L264">            Objects.requireNonNull(action, &quot;action&quot;);</span>
<span class="nc" id="L265">            Objects.requireNonNull(instance, &quot;build() was already called.&quot;);</span>
<span class="nc" id="L266">            instance.schema.defineAfterAction(pass, rule, action);</span>
<span class="nc" id="L267">            return this;</span>
        }

        /**
         * Given an object containing properly annotated methods,
         * define the conditions and actions defined therein.
         *
         * @param object contains condition and action definitions.
         * @return this.
         */
        public Builder defineViaAnnotations (final Object object)
        {
<span class="nc" id="L279">            Objects.requireNonNull(object, &quot;object&quot;);</span>
<span class="nc" id="L280">            Objects.requireNonNull(instance, &quot;build() was already called.&quot;);</span>
<span class="nc" id="L281">            instance.schema.defineViaReflection(object);</span>
<span class="nc" id="L282">            return this;</span>
        }

        /**
         * This method specifies the action to perform
         * when a match attempt is unsuccessful.
         *
         * @param handler will handle unsuccessful matches.
         * @return this.
         */
        public Builder setFailureHandler (final Consumer&lt;Optional&lt;Sexpr&gt;&gt; handler)
        {
<span class="nc" id="L294">            instance.schema.setFailureHandler(handler);</span>
<span class="nc" id="L295">            return this;</span>
        }

        /**
         * Use this method to obtain the new schema object.
         *
         * @return the new matcher.
         */
        public SexprSchema build ()
        {
<span class="nc" id="L305">            final SexprSchema result = instance;</span>
<span class="nc" id="L306">            instance = null;</span>
<span class="nc" id="L307">            return result;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>