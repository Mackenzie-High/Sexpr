<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SList.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Sexpr&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.sexpr</a> &gt; <span class="el_source">SList.java</span></div><h1>SList.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2017 Michael Mackenzie High
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.mackenziehigh.sexpr;

import com.mackenziehigh.sexpr.internal.Parser;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Queue;
import java.util.Scanner;
import java.util.TreeMap;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/**
 * Symbolic List.
 *
 * &lt;p&gt;
 * Textually, a SList consists of an opening parenthesis,
 * a the series of elements separated by spaces,
 * followed by a closing parenthesis.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * All instances of this interface are immutable.
 * &lt;/p&gt;
 */
public final class SList
        extends AbstractList&lt;Sexpr&gt;
        implements Sexpr&lt;SList&gt;
{

    private final ArrayList&lt;Sexpr&gt; elements;

    private final SourceLocation location;

    private final int treeLeafCount;

    private final int treeHeight;

    private final int treeSize;

    /**
     * Pre-computed hashCode(), per the contract in the List interface.
     */
    private final int hash;

    /**
     * Sole Constructor.
     *
     * @param location will be the location() of this list.
     * @param elements will be the elements in this list.
     */
    private SList (final SourceLocation location,
                   final Iterator&lt;? extends Sexpr&gt; elements)
<span class="fc" id="L84">    {</span>
<span class="fc" id="L85">        this.location = Objects.requireNonNull(location);</span>
<span class="fc" id="L86">        this.elements = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L87">        elements.forEachRemaining(x -&gt; this.elements.add(Objects.requireNonNull(x, &quot;A symbolic-list cannot contain null.&quot;)));</span>
<span class="fc" id="L88">        this.elements.trimToSize();</span>
<span class="fc" id="L89">        this.treeSize = this.elements.stream().mapToInt(x -&gt; x.treeSize()).sum() + 1;</span>
<span class="fc" id="L90">        this.treeHeight = this.elements.stream().mapToInt(x -&gt; x.treeHeight()).max().orElse(0) + 1;</span>
<span class="fc" id="L91">        this.treeLeafCount = this.elements.stream().mapToInt(x -&gt; x.treeLeafCount()).sum();</span>
<span class="fc" id="L92">        this.hash = 31 * this.elements.stream().mapToInt(x -&gt; x.hashCode()).sum();</span>
<span class="fc" id="L93">    }</span>

    /**
     * Factory Method.
     *
     * @param elements will be the elements in this list.
     * @return the new symbolic-list.
     */
    public static SList of (final Sexpr... elements)
    {
<span class="fc" id="L103">        return new SList(SourceLocation.DEFAULT, Arrays.asList(elements).iterator());</span>
    }

    /**
     * Factory Method.
     *
     * @param location will be the location() of this list.
     * @param elements will be the elements in this list.
     * @return the new symbolic-list.
     */
    public static SList of (final SourceLocation location,
                            final Sexpr... elements)
    {
<span class="fc" id="L116">        return new SList(location, Arrays.asList(elements).iterator());</span>
    }

    /**
     * Factory Method.
     *
     * @param list contains the elements for the new list.
     * @return the new symbolic-list.
     */
    public static SList copyOf (final Iterable&lt;? extends Sexpr&gt; list)
    {
<span class="fc" id="L127">        return new SList(SourceLocation.DEFAULT, list.iterator());</span>
    }

    /**
     * Factory Method.
     *
     * @param location will be the location() of this list.
     * @param list contains the elements for the new list.
     * @return the new symbolic-list.
     */
    public static SList copyOf (final SourceLocation location,
                                final Iterable&lt;? extends Sexpr&gt; list)
    {
<span class="fc" id="L140">        return new SList(location, list.iterator());</span>
    }

    /**
     * Factory Method.
     *
     * @param stream contains the elements for the new list.
     * @return the new symbolic-list.
     */
    public static SList copyOf (final Stream&lt;? extends Sexpr&gt; stream)
    {
<span class="fc" id="L151">        return new SList(SourceLocation.DEFAULT, stream.iterator());</span>
    }

    /**
     * Factory Method.
     *
     * @param location will be the location() of this list.
     * @param stream contains the elements for the new list.
     * @return the new symbolic-list.
     */
    public static SList copyOf (final SourceLocation location,
                                final Stream&lt;? extends Sexpr&gt; stream)
    {
<span class="fc" id="L164">        return new SList(location, stream.iterator());</span>
    }

    /**
     * Factory Method.
     *
     * @param stream contains the elements for the new list.
     * @return the new symbolic-list.
     */
    public static SList copyOf (final Iterator&lt;? extends Sexpr&gt; stream)
    {
<span class="fc" id="L175">        return new SList(SourceLocation.DEFAULT, stream);</span>
    }

    /**
     * Factory Method.
     *
     * @param location will be the location() of this list.
     * @param stream contains the elements for the new list.
     * @return the new symbolic-list.
     */
    public static SList copyOf (final SourceLocation location,
                                final Iterator&lt;? extends Sexpr&gt; stream)
    {
<span class="fc" id="L188">        return new SList(location, stream);</span>
    }

    /**
     * This method creates a new two-dimensional list from the given map.
     *
     * &lt;p&gt;
     * The result will be a list of lists.
     * Each inner list will correspond to a single entry in the map.
     * Each inner list will have exactly two elements.
     * The first element is the key from the map entry.
     * The second element is the value from the map entry.
     * &lt;/p&gt;
     *
     * @param location will be the location() of this list.
     * @param map contains the entries to add to the list.
     * @return the new symbolic-list.
     */
    public static SList fromMap (final SourceLocation location,
                                 final Map&lt;? extends Sexpr, ? extends Sexpr&gt; map)
    {
<span class="fc" id="L209">        return copyOf(location, createMap(location, map));</span>
    }

    /**
     * This method creates a new two-dimensional list from the given map.
     *
     * &lt;p&gt;
     * The result will be a list of lists.
     * Each inner list will correspond to a single entry in the map.
     * Each inner list will have exactly three elements.
     * The first element will be the key from the map entry.
     * the second element will be the given separator.
     * The third element will be the value from the map entry.
     * &lt;/p&gt;
     *
     * @param location will be the location() of this list.
     * @param map contains the entries to add to the list.
     * @param separator will be used as the key-value separator.
     * @return the new symbolic-list.
     */
    public static SList fromMap (final SourceLocation location,
                                 final Map&lt;? extends Sexpr, ? extends Sexpr&gt; map,
                                 final Sexpr separator)
    {
<span class="fc" id="L233">        return copyOf(location, createMap(location, map, separator));</span>
    }

    private static List&lt;Sexpr&gt; createMap (final SourceLocation location,
                                          final Map&lt;? extends Sexpr, ? extends Sexpr&gt; map)
    {
<span class="fc" id="L239">        final List&lt;Sexpr&gt; outer = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L240">        map.forEach((x, y) -&gt; outer.add(SList.of(location, x, y)));</span>
<span class="fc" id="L241">        return outer;</span>
    }

    private static List&lt;Sexpr&gt; createMap (final SourceLocation location,
                                          final Map&lt;? extends Sexpr, ? extends Sexpr&gt; map,
                                          final Sexpr separator)
    {
<span class="fc" id="L248">        final List&lt;Sexpr&gt; outer = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L249">        map.forEach((x, y) -&gt; outer.add(SList.of(location, x, separator, y)));</span>
<span class="fc" id="L250">        return outer;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Sexpr get (final int i)
    {
<span class="fc" id="L259">        return elements.get(i);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isAtom ()
    {
<span class="fc" id="L268">        return false;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isList ()
    {
<span class="fc" id="L277">        return true;</span>
    }

    /**
     * This method retrieves the first element of this list.
     *
     * @return the first element, or null, if the list is empty.
     */
    public Sexpr first ()
    {
<span class="fc bfc" id="L287" title="All 2 branches covered.">        return isEmpty() ? null : get(0);</span>
    }

    /**
     * This method retrieves the last element of this list.
     *
     * @return the last element, or null, if the list is empty.
     */
    public Sexpr last ()
    {
<span class="fc bfc" id="L297" title="All 2 branches covered.">        return isEmpty() ? null : get(size() - 1);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public SourceLocation location ()
    {
<span class="fc" id="L306">        return location;</span>
    }

    /**
     * This method obtains a mutator that can be used to
     * non-destructively modify the tree rooted at this node.
     *
     * @return the mutator.
     */
    public TreeMutator mutator ()
    {
<span class="fc" id="L317">        return new TreeMutator(this);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int size ()
    {
<span class="fc" id="L326">        return elements.size();</span>
    }

    /**
     * This method retrieves the sub-list containing
     * all of the elements of this list,
     * except for the first element.
     *
     * @return the tail sub-list.
     */
    public SList tail ()
    {
<span class="fc bfc" id="L338" title="All 2 branches covered.">        return isEmpty() ? this : copyOf(location, subList(1, size()));</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean bfs (final Predicate&lt;Sexpr&gt; condition)
    {
<span class="fc" id="L347">        final Queue&lt;Sexpr&gt; queue = new LinkedList&lt;&gt;();</span>

<span class="fc" id="L349">        queue.add(this);</span>

<span class="fc bfc" id="L351" title="All 2 branches covered.">        while (queue.isEmpty() == false)</span>
        {
<span class="fc" id="L353">            final Sexpr element = queue.remove();</span>

<span class="fc bfc" id="L355" title="All 2 branches covered.">            if (condition.test(element))</span>
            {
<span class="fc" id="L357">                return true;</span>
            }
<span class="fc bfc" id="L359" title="All 2 branches covered.">            else if (element.isList())</span>
            {
<span class="fc" id="L361">                queue.addAll((SList) element);</span>
            }
<span class="fc" id="L363">        }</span>

<span class="fc" id="L365">        return false;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean dfs (final Predicate&lt;Sexpr&gt; condition)
    {
<span class="fc" id="L374">        return preorder(condition);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean preorder (final Predicate&lt;Sexpr&gt; condition)
    {
<span class="fc bfc" id="L383" title="All 4 branches covered.">        return condition.test(this) || stream().anyMatch(x -&gt; x.dfs(condition));</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean postorder (final Predicate&lt;Sexpr&gt; condition)
    {
<span class="fc bfc" id="L392" title="All 4 branches covered.">        return stream().anyMatch(x -&gt; x.postorder(condition)) || condition.test(this);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void transverse (final Consumer&lt;Sexpr&gt; before,
                            final Consumer&lt;Sexpr&gt; after)
    {
<span class="fc" id="L402">        before.accept(this);</span>
<span class="fc" id="L403">        stream().forEach(x -&gt; x.transverse(before, after));</span>
<span class="fc" id="L404">        after.accept(this);</span>
<span class="fc" id="L405">    }</span>

    /**
     * This method retrieves this value, as a map.
     *
     * &lt;p&gt;
     * This list must be a list of sub-lists.
     * Each sub-list will correspond to an entry in the new map.
     * The first element in the sub-list will be used as a map-key.
     * The last element in the sub-list will be used as a map-value.
     * If the same map-key occurs multiple times, the last entry will prevail.
     * &lt;/p&gt;
     *
     * @return the immutable value, if possible.
     */
    public Optional&lt;Map&lt;Sexpr, Sexpr&gt;&gt; asMap ()
    {
<span class="fc" id="L422">        final Map&lt;Sexpr, Sexpr&gt; map = new TreeMap&lt;&gt;();</span>

<span class="fc bfc" id="L424" title="All 2 branches covered.">        for (Sexpr element : this)</span>
        {
<span class="fc bfc" id="L426" title="All 2 branches covered.">            if (element.isList() == false)</span>
            {
<span class="fc" id="L428">                return Optional.empty();</span>
            }
<span class="fc bfc" id="L430" title="All 2 branches covered.">            else if (((SList) element).size() &lt; 2)</span>
            {
<span class="fc" id="L432">                return Optional.empty();</span>
            }
            else
            {
<span class="fc" id="L436">                final SList entry = (SList) element;</span>
<span class="fc" id="L437">                map.put(entry.first(), entry.last());</span>
            }
<span class="fc" id="L439">        }</span>

<span class="fc" id="L441">        return Optional.of(Collections.unmodifiableMap(map));</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int treeHeight ()
    {
<span class="fc" id="L450">        return treeHeight;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int treeLeafCount ()
    {
<span class="fc" id="L459">        return treeLeafCount;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int treeSize ()
    {
<span class="fc" id="L468">        return treeSize;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public final boolean equals (final Object other)
    {
<span class="fc bfc" id="L477" title="All 2 branches covered.">        if (other == this)</span>
        {
<span class="fc" id="L479">            return true;</span>
        }
<span class="fc bfc" id="L481" title="All 2 branches covered.">        else if (other == null)</span>
        {
<span class="fc" id="L483">            return false;</span>
        }
<span class="fc bfc" id="L485" title="All 2 branches covered.">        else if (hash != other.hashCode())</span>
        {
<span class="fc" id="L487">            return false;</span>
        }
<span class="fc bfc" id="L489" title="All 2 branches covered.">        else if (other instanceof SList == false)</span>
        {
<span class="fc" id="L491">            return false;</span>
        }
        else
        {
<span class="fc" id="L495">            final SList otherList = (SList) other;</span>
<span class="fc" id="L496">            final boolean result = elements.equals(otherList.elements);</span>
<span class="fc" id="L497">            return result;</span>
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int hashCode ()
    {
<span class="fc" id="L507">        return hash;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String toString ()
    {
<span class="fc" id="L516">        final StringBuilder str = new StringBuilder();</span>
<span class="fc" id="L517">        str.append('(');</span>
<span class="fc" id="L518">        IntStream.range(0, size() - 1).forEach(i -&gt; str.append(get(i)).append(&quot; &quot;));</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">        str.append(isEmpty() ? &quot;&quot; : last());</span>
<span class="fc" id="L520">        str.append(')');</span>
<span class="fc" id="L521">        return str.toString();</span>
    }

    /**
     * This method converts the textual representation of a SList
     * to an actual corresponding SList object.
     *
     * &lt;p&gt;
     * This method inserts an implicit symbolic-list into the input.
     * For example, the input &quot;(1 2) (3 4)&quot; will produce a SList equivalent to &quot;((1 2) (3 4))&quot;.
     * &lt;/p&gt;
     *
     * @param location is a human-readable string indicating where the input came form.
     * @param input is the input to parse.
     * @return the resulting symbolic-list.
     */
    public static SList parse (final String location,
                               final String input)
    {
<span class="fc" id="L540">        final SList root = Parser.parse(location, input);</span>
<span class="fc" id="L541">        return root;</span>
    }

    /**
     * This method converts the textual representation of a resource file
     * to an actual corresponding SList object.
     *
     * &lt;p&gt;
     * See method parse(*) for more parsing details.
     * &lt;/p&gt;
     *
     * @param path is the path to the resource file.
     * @return the new symbolic-list.
     * @throws IOException if the resource cannot be read.
     */
    public static SList parseResource (final String path)
            throws IOException
    {
<span class="nc" id="L559">        final StringBuilder text = new StringBuilder();</span>

<span class="nc" id="L561">        try (InputStream in = SList.class.getResourceAsStream(path);</span>
<span class="nc" id="L562">             BufferedInputStream bin = new BufferedInputStream(in);</span>
<span class="nc" id="L563">             Scanner scanner = new Scanner(bin))</span>
        {
<span class="nc bnc" id="L565" title="All 2 branches missed.">            while (scanner.hasNextLine())</span>
            {
<span class="nc" id="L567">                text.append(scanner.nextLine()).append('\n');</span>
            }
<span class="nc bnc" id="L569" title="All 24 branches missed.">        }</span>
<span class="nc" id="L570">        catch (IOException | RuntimeException ex)</span>
        {
<span class="nc" id="L572">            throw ex;</span>
<span class="nc" id="L573">        }</span>

<span class="nc" id="L575">        return parse(path, text.toString());</span>
    }

    /**
     * This method converts the textual representation of a text file
     * to an actual corresponding SList object.
     *
     * &lt;p&gt;
     * See method parse(*) for more parsing details.
     * &lt;/p&gt;
     *
     * @param file is the path to the file.
     * @return the new symbolic-list.
     * @throws IOException if the resource cannot be read.
     */
    public static SList parseFile (final File file)
            throws IOException
    {
<span class="nc" id="L593">        final String source = file.toString();</span>
<span class="nc" id="L594">        final StringBuilder content = new StringBuilder();</span>
<span class="nc" id="L595">        Files.readAllLines(file.toPath(), Charset.forName(&quot;UTF-8&quot;))</span>
<span class="nc" id="L596">                .forEach(line -&gt; content.append(line).append('\n'));</span>
<span class="nc" id="L597">        return parse(source, content.toString());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>