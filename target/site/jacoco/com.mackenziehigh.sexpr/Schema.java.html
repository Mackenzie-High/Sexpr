<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Schema.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sexpr</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.sexpr</a> &gt; <span class="el_source">Schema.java</span></div><h1>Schema.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2017 Michael Mackenzie High
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.mackenziehigh.sexpr;

import com.mackenziehigh.sexpr.internal.schema.InternalAnnotator;
import com.mackenziehigh.sexpr.internal.schema.InternalSchema;
import com.mackenziehigh.sexpr.internal.schema.InternalSchemaParser;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.function.Predicate;

/**
 * An instance of this class can be used to determine
 * whether a symbolic-expression matches a pattern.
 */
public final class Schema
{
    /**
     * Use an instance of this class to create a &lt;code&gt;Schema&lt;/code&gt; object.
     */
    public static final class Builder
    {

        /**
         * This is the instance that is being constructed.
         */
<span class="fc" id="L41">        private final InternalSchema instance = new InternalSchema();</span>

        /**
         * This flag becomes true, when &lt;code&gt;build()&lt;/code&gt; get called.
         */
<span class="fc" id="L46">        private volatile boolean built = false;</span>

        /**
         * Sole Constructor.
         */
        private Builder ()
<span class="fc" id="L52">        {</span>
            // Pass.
<span class="fc" id="L54">        }</span>

        private void requireNotBuilt ()
        {
<span class="pc bpc" id="L58" title="1 of 2 branches missed.">            if (built)</span>
            {
<span class="nc" id="L60">                throw new IllegalStateException(&quot;build() was already called.&quot;);</span>
            }
<span class="fc" id="L62">        }</span>

        /*
         * This method imports the schema rules defined in the given string.
         *
         * @param schema is the textual schema.
         * @return this.
         */
        public Builder include (final String schema)
        {
<span class="nc" id="L72">            requireNotBuilt();</span>
<span class="nc" id="L73">            final StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();</span>
<span class="nc" id="L74">            final StackTraceElement caller = stackTrace[stackTrace.length - 1];</span>
<span class="nc" id="L75">            final String location = caller.toString();</span>
<span class="nc" id="L76">            InternalSchemaParser.parse(instance, location, schema);</span>
<span class="nc" id="L77">            return this;</span>
        }

        /**
         * This method imports the schema rules defined in the given string.
         *
         * @param source is a human-readable string indicating where the schema is from.
         * @param schema is the textual schema to parse.
         * @return this.
         */
        public Builder include (final String source,
                                final String schema)
        {
<span class="fc" id="L90">            requireNotBuilt();</span>
<span class="fc" id="L91">            InternalSchemaParser.parse(instance, source, schema);</span>
<span class="fc" id="L92">            return this;</span>
        }

        /**
         * Use this method to define a predicate that can be used within a schema.
         *
         * &lt;p&gt;
         * Inside of the schema, the predicate must be referenced via a 'require' rule.
         * &lt;/p&gt;
         *
         * @param name is the name that will be used to identify the predicate.
         * @param condition is the predicate itself.
         * @return this.
         * @throws IllegalArgumentException if the name already identifies a predicate.
         */
        public Builder condition (String name,
                                  Predicate&lt;Sexpr&gt; condition)
        {
<span class="fc" id="L110">            requireNotBuilt();</span>
<span class="fc" id="L111">            Objects.requireNonNull(name, &quot;name&quot;);</span>
<span class="fc" id="L112">            Objects.requireNonNull(condition, &quot;condition&quot;);</span>
<span class="fc" id="L113">            instance.defineCondition(name, condition);</span>
<span class="fc" id="L114">            return this;</span>
        }

        /**
         * Use this method to declare another translation pass.
         *
         * &lt;p&gt;
         * Call this method multiple times in order to declare multiple passes.
         * The translation passes will occur in the order of those invocations.
         * &lt;/p&gt;
         *
         * @param name is the name of the new translation pass.
         * @return this.
         */
        public Builder pass (String name)
        {
<span class="fc" id="L130">            requireNotBuilt();</span>
<span class="fc" id="L131">            Objects.requireNonNull(name, &quot;name&quot;);</span>
<span class="fc" id="L132">            instance.definePass(name);</span>
<span class="fc" id="L133">            return this;</span>
        }

        /**
         * Use this method to define an action that will be executed before
         * matches of a named rule during a specific pass.
         *
         * @param pass is the name of the pass that this action applies to.
         * @param rule is the name of the rule that this action applies to.
         * @param action is the action itself.
         * @return this.
         * @throws IllegalArgumentException if the name already identifies a action.
         */
        public Builder before (String pass,
                               String rule,
                               Consumer&lt;Sexpr&gt; action)
        {
<span class="fc" id="L150">            requireNotBuilt();</span>
<span class="fc" id="L151">            Objects.requireNonNull(pass, &quot;pass&quot;);</span>
<span class="fc" id="L152">            Objects.requireNonNull(rule, &quot;rule&quot;);</span>
<span class="fc" id="L153">            Objects.requireNonNull(action, &quot;action&quot;);</span>
<span class="fc" id="L154">            instance.defineBeforeAction(pass, rule, action);</span>
<span class="fc" id="L155">            return this;</span>
        }

        /**
         * Use this method to define an action that will be executed after
         * matches of a named rule during a specific pass.
         *
         * @param pass is the name of the pass that this action applies to.
         * @param rule is the name of the rule that this action applies to.
         * @param action is the action itself.
         * @return this.
         * @throws IllegalArgumentException if the name already identifies a action.
         */
        public Builder after (String pass,
                              String rule,
                              Consumer&lt;Sexpr&gt; action)
        {
<span class="fc" id="L172">            requireNotBuilt();</span>
<span class="fc" id="L173">            Objects.requireNonNull(pass, &quot;pass&quot;);</span>
<span class="fc" id="L174">            Objects.requireNonNull(rule, &quot;rule&quot;);</span>
<span class="fc" id="L175">            Objects.requireNonNull(action, &quot;action&quot;);</span>
<span class="fc" id="L176">            instance.defineAfterAction(pass, rule, action);</span>
<span class="fc" id="L177">            return this;</span>
        }

        /**
         * Given an object containing properly annotated methods,
         * define the conditions and actions defined therein.
         *
         * @param object contains condition and action definitions.
         * @return this.
         */
        public Builder defineViaAnnotations (Object object)
        {
<span class="fc" id="L189">            requireNotBuilt();</span>
<span class="fc" id="L190">            final InternalAnnotator annotator = new InternalAnnotator(this);</span>
<span class="fc" id="L191">            annotator.defineViaReflection(object);</span>
<span class="fc" id="L192">            return this;</span>
        }

        /**
         * Use this method to obtain the new schema object.
         *
         * @return the new matcher.
         */
        public Schema build ()
        {
<span class="fc" id="L202">            requireNotBuilt();</span>
<span class="fc" id="L203">            built = true;</span>

<span class="fc" id="L205">            instance.validate();</span>

<span class="fc" id="L207">            return new Schema(instance);</span>
        }
    }

    /**
     * Result of a &lt;code&gt;match(Sexpr)&lt;/code&gt; invocation.
     */
    public interface Match
    {
        /**
         * Determine whether this object represents a successful match.
         *
         * @return true, if the match attempt succeeded.
         */
        public boolean isSuccess ();

        /**
         * Determine whether this object represents a unsuccessful match.
         *
         * @return true, if the match attempt failed.
         */
        public boolean isFailure ();

        /**
         * Get the symbolic-expression that was the input to &lt;code&gt;match()&lt;/code&gt;.
         *
         * @return the input.
         */
        public Sexpr&lt;?&gt; input ();

        /**
         * Get the last node of the input that was successfully matched, if any,
         * which is useful for locating and reporting errors in the input.
         *
         * @return the last successfully matched node, if any.
         */
        public Optional&lt;Sexpr&lt;?&gt;&gt; lastSuccess ();

        /**
         * Execute the defined passes and related actions.
         *
         * &lt;p&gt;
         * If the match is successful, then the match-tree
         * will be traversed once for each translation-pass
         * that was defined previously. Upon encountering
         * the successful match of a rule (R) during a
         * translation-pass, the before-actions of (R)
         * will be executed, then the subordinate matches
         * will be visited and their actions will be executed,
         * and then the after-actions of (R) will be executed.
         * &lt;/p&gt;
         *
         * @return this.
         */
        public Match execute ();
    }

    private final InternalSchema internal;

    private Schema (final InternalSchema internal)
<span class="fc" id="L267">    {</span>
<span class="fc" id="L268">        this.internal = internal;</span>
<span class="fc" id="L269">    }</span>

    /**
     * This method determines whether the given symbolic-expression obeys this schema.
     *
     * @param input is the symbolic-expression that this schema may match.
     * @return an object that describes the whether the match was successful or not.
     */
    public Match match (final Sexpr&lt;?&gt; input)
    {
<span class="fc" id="L279">        return internal.match(input);</span>
    }

    /**
     * Builder Factory.
     *
     * @return an object that can be used to build a &lt;code&gt;Schema&lt;/code&gt; object.
     */
    public static Builder newBuilder ()
    {
<span class="fc" id="L289">        return new Builder();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>