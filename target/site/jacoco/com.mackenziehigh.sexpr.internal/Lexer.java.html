<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Lexer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sexpr</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.sexpr.internal</a> &gt; <span class="el_source">Lexer.java</span></div><h1>Lexer.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2017 Michael Mackenzie High
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.mackenziehigh.sexpr.internal;

/* The following code was generated by JFlex 1.4.3 on 9/3/18, 9:32 PM */
/**
 * This class is a scanner generated by
 * &lt;a href=&quot;http://www.jflex.de/&quot;&gt;JFlex&lt;/a&gt; 1.4.3
 * on 9/3/18, 9:32 PM from the specification file
 * &lt;tt&gt;Lexer.txt&lt;/tt&gt;
 */
final class Lexer
{

    /**
     * This character denotes the end of file
     */
    public static final int YYEOF = -1;

    /**
     * initial size of the lookahead buffer
     */
    private static final int ZZ_BUFFERSIZE = 16384;

    /**
     * lexical states
     */
    public static final int YYINITIAL = 0;

    /**
     * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
     * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
     * at the beginning of a line
     * l is of the form l = 2*k, k a non negative integer
     */
<span class="fc" id="L49">    private static final int ZZ_LEXSTATE[] =</span>
    {
        0,
        0
    };

    /**
     * Translates characters to character classes
     */
    private static final String ZZ_CMAP_PACKED
                                = &quot;\11\0\1\10\1\7\2\0\1\7\22\0\1\10\1\0\1\3\1\6&quot;
                                  + &quot;\3\0\1\2\1\11\1\5\26\0\1\1\33\0\1\4\uffa3\0&quot;;

    /**
     * Translates characters to character classes
     */
<span class="fc" id="L65">    private static final char[] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);</span>

    /**
     * Translates DFA states to action switch labels.
     */
<span class="fc" id="L70">    private static final int[] ZZ_ACTION = zzUnpackAction();</span>

    private static final String ZZ_ACTION_PACKED_0
                                = &quot;\1\0\1\1\3\2\1\3\2\4\1\5\3\0\1\6&quot;
                                  + &quot;\2\0\1\7\1\0\1\10\1\11\1\6\1\7&quot;;

    private static int[] zzUnpackAction ()
    {
<span class="fc" id="L78">        int[] result = new int[21];</span>
<span class="fc" id="L79">        int offset = 0;</span>
<span class="fc" id="L80">        offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);</span>
<span class="fc" id="L81">        return result;</span>
    }

    private static int zzUnpackAction (String packed,
                                       int offset,
                                       int[] result)
    {
<span class="fc" id="L88">        int i = 0;</span>
        /* index in packed string  */
<span class="fc" id="L90">        int j = offset;</span>
        /* index in unpacked array */
<span class="fc" id="L92">        int l = packed.length();</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">        while (i &lt; l)</span>
        {
<span class="fc" id="L95">            int count = packed.charAt(i++);</span>
<span class="fc" id="L96">            int value = packed.charAt(i++);</span>
            do
            {
<span class="fc" id="L99">                result[j++] = value;</span>
            }
<span class="fc bfc" id="L101" title="All 2 branches covered.">            while (--count &gt; 0);</span>
<span class="fc" id="L102">        }</span>
<span class="fc" id="L103">        return j;</span>
    }

    /**
     * Translates a state to a row index in the transition table
     */
<span class="fc" id="L109">    private static final int[] ZZ_ROWMAP = zzUnpackRowMap();</span>

    private static final String ZZ_ROWMAP_PACKED_0
                                = &quot;\0\0\0\12\0\24\0\36\0\50\0\62\0\74\0\62&quot;
                                  + &quot;\0\62\0\106\0\120\0\36\0\62\0\132\0\50\0\62&quot;
                                  + &quot;\0\144\0\62\0\62\0\36\0\50&quot;;

    private static int[] zzUnpackRowMap ()
    {
<span class="fc" id="L118">        int[] result = new int[21];</span>
<span class="fc" id="L119">        int offset = 0;</span>
<span class="fc" id="L120">        offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);</span>
<span class="fc" id="L121">        return result;</span>
    }

    private static int zzUnpackRowMap (String packed,
                                       int offset,
                                       int[] result)
    {
<span class="fc" id="L128">        int i = 0;</span>
        /* index in packed string  */
<span class="fc" id="L130">        int j = offset;</span>
        /* index in unpacked array */
<span class="fc" id="L132">        int l = packed.length();</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">        while (i &lt; l)</span>
        {
<span class="fc" id="L135">            int high = packed.charAt(i++) &lt;&lt; 16;</span>
<span class="fc" id="L136">            result[j++] = high | packed.charAt(i++);</span>
<span class="fc" id="L137">        }</span>
<span class="fc" id="L138">        return j;</span>
    }

    /**
     * The transition table of the DFA
     */
<span class="fc" id="L144">    private static final int[] ZZ_TRANS = zzUnpackTrans();</span>

    private static final String ZZ_TRANS_PACKED_0
                                = &quot;\1\2\1\3\1\4\1\5\1\2\1\6\1\7\2\10&quot;
                                  + &quot;\1\11\1\2\3\0\1\2\7\0\1\12\1\13\6\0&quot;
                                  + &quot;\2\14\1\15\1\14\1\16\5\14\3\17\1\20\1\21&quot;
                                  + &quot;\5\17\12\0\7\7\1\0\2\7\2\12\1\22\7\12&quot;
                                  + &quot;\3\13\1\23\6\13\2\14\1\24\1\14\1\16\5\14&quot;
                                  + &quot;\3\17\1\25\1\21\5\17&quot;;

    private static int[] zzUnpackTrans ()
    {
<span class="fc" id="L156">        int[] result = new int[110];</span>
<span class="fc" id="L157">        int offset = 0;</span>
<span class="fc" id="L158">        offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);</span>
<span class="fc" id="L159">        return result;</span>
    }

    private static int zzUnpackTrans (String packed,
                                      int offset,
                                      int[] result)
    {
<span class="fc" id="L166">        int i = 0;</span>
        /* index in packed string  */
<span class="fc" id="L168">        int j = offset;</span>
        /* index in unpacked array */
<span class="fc" id="L170">        int l = packed.length();</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">        while (i &lt; l)</span>
        {
<span class="fc" id="L173">            int count = packed.charAt(i++);</span>
<span class="fc" id="L174">            int value = packed.charAt(i++);</span>
<span class="fc" id="L175">            value--;</span>
            do
            {
<span class="fc" id="L178">                result[j++] = value;</span>
            }
<span class="fc bfc" id="L180" title="All 2 branches covered.">            while (--count &gt; 0);</span>
<span class="fc" id="L181">        }</span>
<span class="fc" id="L182">        return j;</span>
    }


    /* error codes */
    private static final int ZZ_UNKNOWN_ERROR = 0;

    private static final int ZZ_NO_MATCH = 1;

    private static final int ZZ_PUSHBACK_2BIG = 2;

    /* error messages for the codes above */
<span class="fc" id="L194">    private static final String ZZ_ERROR_MSG[] =</span>
    {
        &quot;Unkown internal scanner error&quot;,
        &quot;Error: could not match input&quot;,
        &quot;Error: pushback value was too large&quot;
    };

    /**
     * ZZ_ATTRIBUTE[aState] contains the attributes of state &lt;code&gt;aState&lt;/code&gt;
     */
<span class="fc" id="L204">    private static final int[] ZZ_ATTRIBUTE = zzUnpackAttribute();</span>

    private static final String ZZ_ATTRIBUTE_PACKED_0
                                = &quot;\1\0\4\1\1\11\1\1\2\11\3\0\1\11\2\0&quot;
                                  + &quot;\1\11\1\0\2\11\2\1&quot;;

    private static int[] zzUnpackAttribute ()
    {
<span class="fc" id="L212">        int[] result = new int[21];</span>
<span class="fc" id="L213">        int offset = 0;</span>
<span class="fc" id="L214">        offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);</span>
<span class="fc" id="L215">        return result;</span>
    }

    private static int zzUnpackAttribute (String packed,
                                          int offset,
                                          int[] result)
    {
<span class="fc" id="L222">        int i = 0;</span>
        /* index in packed string  */
<span class="fc" id="L224">        int j = offset;</span>
        /* index in unpacked array */
<span class="fc" id="L226">        int l = packed.length();</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">        while (i &lt; l)</span>
        {
<span class="fc" id="L229">            int count = packed.charAt(i++);</span>
<span class="fc" id="L230">            int value = packed.charAt(i++);</span>
            do
            {
<span class="fc" id="L233">                result[j++] = value;</span>
            }
<span class="fc bfc" id="L235" title="All 2 branches covered.">            while (--count &gt; 0);</span>
<span class="fc" id="L236">        }</span>
<span class="fc" id="L237">        return j;</span>
    }

    /**
     * the input device
     */
    private java.io.Reader zzReader;

    /**
     * the current state of the DFA
     */
    private int zzState;

    /**
     * the current lexical state
     */
<span class="fc" id="L253">    private int zzLexicalState = YYINITIAL;</span>

    /**
     * this buffer contains the current text to be matched and is
     * the source of the yytext() string
     */
<span class="fc" id="L259">    private char zzBuffer[] = new char[ZZ_BUFFERSIZE];</span>

    /**
     * the textposition at the last accepting state
     */
    private int zzMarkedPos;

    /**
     * the current text position in the buffer
     */
    private int zzCurrentPos;

    /**
     * startRead marks the beginning of the yytext() string in the buffer
     */
    private int zzStartRead;

    /**
     * endRead marks the last character in the buffer, that has been read
     * from input
     */
    private int zzEndRead;

    /**
     * number of newlines encountered up to the start of the matched text
     */
    private int yyline;

    /**
     * the number of characters up to the start of the matched text
     */
    private int yychar;

    /**
     * the number of characters from the last newline up to the start of the
     * matched text
     */
    private int yycolumn;

    /**
     * zzAtBOL == true &lt;=&gt; the scanner is currently at the beginning of a line
     */
<span class="fc" id="L301">    private boolean zzAtBOL = true;</span>

    /**
     * zzAtEOF == true &lt;=&gt; the scanner is at the EOF
     */
    private boolean zzAtEOF;

    /**
     * denotes if the user-EOF-code has already been executed
     */
    private boolean zzEOFDone;

    /* user code: */
<span class="fc" id="L314">    final LexerStack stack = new LexerStack();</span>

    /**
     * Creates a new scanner
     * There is also a java.io.InputStream version of this constructor.
     *
     * @param in the java.io.Reader to read input from.
     */
    Lexer (java.io.Reader in)
<span class="fc" id="L323">    {</span>
<span class="fc" id="L324">        this.zzReader = in;</span>
<span class="fc" id="L325">    }</span>

    /**
     * Creates a new scanner.
     * There is also java.io.Reader version of this constructor.
     *
     * @param in the java.io.Inputstream to read input from.
     */
    Lexer (java.io.InputStream in)
    {
<span class="nc" id="L335">        this(new java.io.InputStreamReader(in));</span>
<span class="nc" id="L336">    }</span>

    /**
     * Unpacks the compressed character translation table.
     *
     * @param packed the packed character translation table
     * @return the unpacked character translation table
     */
    private static char[] zzUnpackCMap (String packed)
    {
<span class="fc" id="L346">        char[] map = new char[0x10000];</span>
<span class="fc" id="L347">        int i = 0;</span>
        /* index in packed string  */
<span class="fc" id="L349">        int j = 0;</span>
        /* index in unpacked array */
<span class="fc bfc" id="L351" title="All 2 branches covered.">        while (i &lt; 38)</span>
        {
<span class="fc" id="L353">            int count = packed.charAt(i++);</span>
<span class="fc" id="L354">            char value = packed.charAt(i++);</span>
            do
            {
<span class="fc" id="L357">                map[j++] = value;</span>
            }
<span class="fc bfc" id="L359" title="All 2 branches covered.">            while (--count &gt; 0);</span>
<span class="fc" id="L360">        }</span>
<span class="fc" id="L361">        return map;</span>
    }

    /**
     * Refills the input buffer.
     *
     * @return      &lt;code&gt;false&lt;/code&gt;, iff there was new input.
     *
     * @exception java.io.IOException if any I/O-Error occurs
     */
    private boolean zzRefill ()
            throws java.io.IOException
    {

        /* first: make room (if you can) */
<span class="fc bfc" id="L376" title="All 2 branches covered.">        if (zzStartRead &gt; 0)</span>
        {
<span class="fc" id="L378">            System.arraycopy(zzBuffer, zzStartRead,</span>
                             zzBuffer, 0,
                             zzEndRead - zzStartRead);

            /* translate stored positions */
<span class="fc" id="L383">            zzEndRead -= zzStartRead;</span>
<span class="fc" id="L384">            zzCurrentPos -= zzStartRead;</span>
<span class="fc" id="L385">            zzMarkedPos -= zzStartRead;</span>
<span class="fc" id="L386">            zzStartRead = 0;</span>
        }

        /* is the buffer big enough? */
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">        if (zzCurrentPos &gt;= zzBuffer.length)</span>
        {
            /* if not: blow it up */
<span class="nc" id="L393">            char newBuffer[] = new char[zzCurrentPos * 2];</span>
<span class="nc" id="L394">            System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);</span>
<span class="nc" id="L395">            zzBuffer = newBuffer;</span>
        }

        /* finally: fill the buffer with new input */
<span class="fc" id="L399">        int numRead = zzReader.read(zzBuffer, zzEndRead,</span>
                                    zzBuffer.length - zzEndRead);

<span class="fc bfc" id="L402" title="All 2 branches covered.">        if (numRead &gt; 0)</span>
        {
<span class="fc" id="L404">            zzEndRead += numRead;</span>
<span class="fc" id="L405">            return false;</span>
        }
        // unlikely but not impossible: read 0 characters, but not at end of stream
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">        if (numRead == 0)</span>
        {
<span class="nc" id="L410">            int c = zzReader.read();</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            if (c == -1)</span>
            {
<span class="nc" id="L413">                return true;</span>
            }
            else
            {
<span class="nc" id="L417">                zzBuffer[zzEndRead++] = (char) c;</span>
<span class="nc" id="L418">                return false;</span>
            }
        }

        // numRead &lt; 0
<span class="fc" id="L423">        return true;</span>
    }

    /**
     * Closes the input stream.
     */
    public final void yyclose ()
            throws java.io.IOException
    {
<span class="nc" id="L432">        zzAtEOF = true;</span>
        /* indicate end of file */
<span class="nc" id="L434">        zzEndRead = zzStartRead;</span>
        /* invalidate buffer    */

<span class="nc bnc" id="L437" title="All 2 branches missed.">        if (zzReader != null)</span>
        {
<span class="nc" id="L439">            zzReader.close();</span>
        }
<span class="nc" id="L441">    }</span>

    /**
     * Resets the scanner to read from a new input stream.
     * Does not close the old reader.
     *
     * All internal variables are reset, the old input stream
     * &lt;b&gt;cannot&lt;/b&gt; be reused (internal buffer is discarded and lost).
     * Lexical state is set to &lt;tt&gt;ZZ_INITIAL&lt;/tt&gt;.
     *
     * @param reader the new input stream
     */
    public final void yyreset (java.io.Reader reader)
    {
<span class="nc" id="L455">        zzReader = reader;</span>
<span class="nc" id="L456">        zzAtBOL = true;</span>
<span class="nc" id="L457">        zzAtEOF = false;</span>
<span class="nc" id="L458">        zzEOFDone = false;</span>
<span class="nc" id="L459">        zzEndRead = zzStartRead = 0;</span>
<span class="nc" id="L460">        zzCurrentPos = zzMarkedPos = 0;</span>
<span class="nc" id="L461">        yyline = yychar = yycolumn = 0;</span>
<span class="nc" id="L462">        zzLexicalState = YYINITIAL;</span>
<span class="nc" id="L463">    }</span>

    /**
     * Returns the current lexical state.
     */
    public final int yystate ()
    {
<span class="nc" id="L470">        return zzLexicalState;</span>
    }

    /**
     * Enters a new lexical state
     *
     * @param newState the new lexical state
     */
    public final void yybegin (int newState)
    {
<span class="nc" id="L480">        zzLexicalState = newState;</span>
<span class="nc" id="L481">    }</span>

    /**
     * Returns the text matched by the current regular expression.
     */
    public final String yytext ()
    {
<span class="fc" id="L488">        return new String(zzBuffer, zzStartRead, zzMarkedPos - zzStartRead);</span>
    }

    /**
     * Returns the character at position &lt;tt&gt;pos&lt;/tt&gt; from the
     * matched text.
     *
     * It is equivalent to yytext().charAt(pos), but faster
     *
     * @param pos the position of the character to fetch.
     * A value from 0 to yylength()-1.
     *
     * @return the character at position pos
     */
    public final char yycharat (int pos)
    {
<span class="nc" id="L504">        return zzBuffer[zzStartRead + pos];</span>
    }

    /**
     * Returns the length of the matched text region.
     */
    public final int yylength ()
    {
<span class="nc" id="L512">        return zzMarkedPos - zzStartRead;</span>
    }

    /**
     * Reports an error that occured while scanning.
     *
     * In a wellformed scanner (no or only correct usage of
     * yypushback(int) and a match-all fallback rule) this method
     * will only be called with things that &quot;Can't Possibly Happen&quot;.
     * If this method is called, something is seriously wrong
     * (e.g. a JFlex bug producing a faulty scanner etc.).
     *
     * Usual syntax/scanner level error handling should be done
     * in error fallback rules.
     *
     * @param errorCode the code of the errormessage to display
     */
    private void zzScanError (int errorCode)
    {
        String message;
        try
        {
<span class="nc" id="L534">            message = ZZ_ERROR_MSG[errorCode];</span>
        }
<span class="nc" id="L536">        catch (ArrayIndexOutOfBoundsException e)</span>
        {
<span class="nc" id="L538">            message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];</span>
<span class="nc" id="L539">        }</span>

<span class="nc" id="L541">        throw new Error(message);</span>
    }

    /**
     * Pushes the specified amount of characters back into the input stream.
     *
     * They will be read again by then next call of the scanning method
     *
     * @param number the number of characters to be read again.
     * This number must not be greater than yylength()!
     */
    public void yypushback (int number)
    {
<span class="nc bnc" id="L554" title="All 2 branches missed.">        if (number &gt; yylength())</span>
        {
<span class="nc" id="L556">            zzScanError(ZZ_PUSHBACK_2BIG);</span>
        }

<span class="nc" id="L559">        zzMarkedPos -= number;</span>
<span class="nc" id="L560">    }</span>

    /**
     * Resumes scanning until the next regular expression is matched,
     * the end of input is encountered or an I/O-Error occurs.
     *
     * @return the next token
     * @exception java.io.IOException if any I/O-Error occurs
     */
    public int yylex ()
            throws java.io.IOException
    {
        int zzInput;
        int zzAction;

        // cached fields:
        int zzCurrentPosL;
        int zzMarkedPosL;
<span class="fc" id="L578">        int zzEndReadL = zzEndRead;</span>
<span class="fc" id="L579">        char[] zzBufferL = zzBuffer;</span>
<span class="fc" id="L580">        char[] zzCMapL = ZZ_CMAP;</span>

<span class="fc" id="L582">        int[] zzTransL = ZZ_TRANS;</span>
<span class="fc" id="L583">        int[] zzRowMapL = ZZ_ROWMAP;</span>
<span class="fc" id="L584">        int[] zzAttrL = ZZ_ATTRIBUTE;</span>

        while (true)
        {
<span class="fc" id="L588">            zzMarkedPosL = zzMarkedPos;</span>

<span class="fc" id="L590">            boolean zzR = false;</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">            for (zzCurrentPosL = zzStartRead; zzCurrentPosL &lt; zzMarkedPosL;</span>
<span class="fc" id="L592">                 zzCurrentPosL++)</span>
            {
<span class="pc bpc" id="L594" title="2 of 4 branches missed.">                switch (zzBufferL[zzCurrentPosL])</span>
                {
                    case '\u000B':
                    case '\u000C':
                    case '\u0085':
                    case '\u2028':
                    case '\u2029':
<span class="nc" id="L601">                        yyline++;</span>
<span class="nc" id="L602">                        yycolumn = 0;</span>
<span class="nc" id="L603">                        zzR = false;</span>
<span class="nc" id="L604">                        break;</span>
                    case '\r':
<span class="nc" id="L606">                        yyline++;</span>
<span class="nc" id="L607">                        yycolumn = 0;</span>
<span class="nc" id="L608">                        zzR = true;</span>
<span class="nc" id="L609">                        break;</span>
                    case '\n':
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">                        if (zzR)</span>
                        {
<span class="nc" id="L613">                            zzR = false;</span>
                        }
                        else
                        {
<span class="fc" id="L617">                            yyline++;</span>
<span class="fc" id="L618">                            yycolumn = 0;</span>
                        }
<span class="fc" id="L620">                        break;</span>
                    default:
<span class="fc" id="L622">                        zzR = false;</span>
<span class="fc" id="L623">                        yycolumn++;</span>
                }
            }

<span class="pc bpc" id="L627" title="1 of 2 branches missed.">            if (zzR)</span>
            {
                // peek one character ahead if it is \n (if we have counted one line too much)
                boolean zzPeek;
<span class="nc bnc" id="L631" title="All 2 branches missed.">                if (zzMarkedPosL &lt; zzEndReadL)</span>
                {
<span class="nc bnc" id="L633" title="All 2 branches missed.">                    zzPeek = zzBufferL[zzMarkedPosL] == '\n';</span>
                }
<span class="nc bnc" id="L635" title="All 2 branches missed.">                else if (zzAtEOF)</span>
                {
<span class="nc" id="L637">                    zzPeek = false;</span>
                }
                else
                {
<span class="nc" id="L641">                    boolean eof = zzRefill();</span>
<span class="nc" id="L642">                    zzEndReadL = zzEndRead;</span>
<span class="nc" id="L643">                    zzMarkedPosL = zzMarkedPos;</span>
<span class="nc" id="L644">                    zzBufferL = zzBuffer;</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">                    if (eof)</span>
                    {
<span class="nc" id="L647">                        zzPeek = false;</span>
                    }
                    else
                    {
<span class="nc bnc" id="L651" title="All 2 branches missed.">                        zzPeek = zzBufferL[zzMarkedPosL] == '\n';</span>
                    }
                }
<span class="nc bnc" id="L654" title="All 2 branches missed.">                if (zzPeek)</span>
                {
<span class="nc" id="L656">                    yyline--;</span>
                }
            }
<span class="fc" id="L659">            zzAction = -1;</span>

<span class="fc" id="L661">            zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;</span>

<span class="fc" id="L663">            zzState = ZZ_LEXSTATE[zzLexicalState];</span>

zzForAction:
            {
                while (true)
                {

<span class="fc bfc" id="L670" title="All 2 branches covered.">                    if (zzCurrentPosL &lt; zzEndReadL)</span>
                    {
<span class="fc" id="L672">                        zzInput = zzBufferL[zzCurrentPosL++];</span>
                    }
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">                    else if (zzAtEOF)</span>
                    {
<span class="nc" id="L676">                        zzInput = YYEOF;</span>
<span class="nc" id="L677">                        break zzForAction;</span>
                    }
                    else
                    {
                        // store back cached positions
<span class="fc" id="L682">                        zzCurrentPos = zzCurrentPosL;</span>
<span class="fc" id="L683">                        zzMarkedPos = zzMarkedPosL;</span>
<span class="fc" id="L684">                        boolean eof = zzRefill();</span>
                        // get translated positions and possibly new buffer
<span class="fc" id="L686">                        zzCurrentPosL = zzCurrentPos;</span>
<span class="fc" id="L687">                        zzMarkedPosL = zzMarkedPos;</span>
<span class="fc" id="L688">                        zzBufferL = zzBuffer;</span>
<span class="fc" id="L689">                        zzEndReadL = zzEndRead;</span>
<span class="fc bfc" id="L690" title="All 2 branches covered.">                        if (eof)</span>
                        {
<span class="fc" id="L692">                            zzInput = YYEOF;</span>
<span class="fc" id="L693">                            break zzForAction;</span>
                        }
                        else
                        {
<span class="fc" id="L697">                            zzInput = zzBufferL[zzCurrentPosL++];</span>
                        }
                    }
<span class="fc" id="L700">                    int zzNext = zzTransL[zzRowMapL[zzState] + zzCMapL[zzInput]];</span>
<span class="fc bfc" id="L701" title="All 2 branches covered.">                    if (zzNext == -1)</span>
                    {
<span class="fc" id="L703">                        break zzForAction;</span>
                    }
<span class="fc" id="L705">                    zzState = zzNext;</span>

<span class="fc" id="L707">                    int zzAttributes = zzAttrL[zzState];</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">                    if ((zzAttributes &amp; 1) == 1)</span>
                    {
<span class="fc" id="L710">                        zzAction = zzState;</span>
<span class="fc" id="L711">                        zzMarkedPosL = zzCurrentPosL;</span>
<span class="fc bfc" id="L712" title="All 2 branches covered.">                        if ((zzAttributes &amp; 8) == 8)</span>
                        {
<span class="fc" id="L714">                            break zzForAction;</span>
                        }
                    }

<span class="fc" id="L718">                }</span>
            }

            // store back cached position
<span class="fc" id="L722">            zzMarkedPos = zzMarkedPosL;</span>

<span class="pc bpc" id="L724" title="9 of 20 branches missed.">            switch (zzAction &lt; 0 ? zzAction : ZZ_ACTION[zzAction])</span>
            {
                case 2:
                {
<span class="nc" id="L728">                    System.out.print(yytext());</span>
                }
                case 10:
<span class="nc" id="L731">                    break;</span>
                case 5:
                {
<span class="fc" id="L734">                    stack.parenOpen(yyline + 1, yycolumn + 1);</span>
                }
                case 11:
<span class="fc" id="L737">                    break;</span>
                case 4:
                { // IGNORE
                }
                case 12:
<span class="fc" id="L742">                    break;</span>
                case 9:
                {
<span class="fc" id="L745">                    stack.pushAtomForm2(yytext(), yyline + 1, yycolumn + 1);</span>
                }
                case 13:
<span class="fc" id="L748">                    break;</span>
                case 3:
                {
<span class="fc" id="L751">                    stack.parenClose();</span>
                }
                case 14:
<span class="fc" id="L754">                    break;</span>
                case 6:
                {
<span class="fc" id="L757">                    stack.pushAtomForm3(yytext(), yyline + 1, yycolumn + 1);</span>
                }
                case 15:
<span class="fc" id="L760">                    break;</span>
                case 7:
                {
<span class="fc" id="L763">                    stack.pushAtomForm4(yytext(), yyline + 1, yycolumn + 1);</span>
                }
                case 16:
<span class="fc" id="L766">                    break;</span>
                case 1:
                {
<span class="fc" id="L769">                    stack.pushAtomForm5(yytext(), yyline + 1, yycolumn + 1);</span>
                }
                case 17:
<span class="fc" id="L772">                    break;</span>
                case 8:
                {
<span class="fc" id="L775">                    stack.pushAtomForm1(yytext(), yyline + 1, yycolumn + 1);</span>
                }
                case 18:
<span class="fc" id="L778">                    break;</span>
                default:
<span class="pc bpc" id="L780" title="2 of 4 branches missed.">                    if (zzInput == YYEOF &amp;&amp; zzStartRead == zzCurrentPos)</span>
                    {
<span class="fc" id="L782">                        zzAtEOF = true;</span>
<span class="fc" id="L783">                        return YYEOF;</span>
                    }
                    else
                    {
<span class="nc" id="L787">                        zzScanError(ZZ_NO_MATCH);</span>
                    }
            }
<span class="fc" id="L790">        }</span>
    }

    /**
     * Runs the scanner on input files.
     *
     * This is a standalone scanner, it will print any unmatched
     * text to System.out unchanged.
     *
     * @param argv the command line, contains the filenames to run
     * the scanner on.
     */
    public static void main (String argv[])
    {
<span class="nc bnc" id="L804" title="All 2 branches missed.">        if (argv.length == 0)</span>
        {
<span class="nc" id="L806">            System.out.println(&quot;Usage : java Lexer &lt;inputfile&gt;&quot;);</span>
        }
        else
        {
<span class="nc bnc" id="L810" title="All 2 branches missed.">            for (int i = 0; i &lt; argv.length; i++)</span>
            {
<span class="nc" id="L812">                Lexer scanner = null;</span>
                try
                {
<span class="nc" id="L815">                    scanner = new Lexer(new java.io.FileReader(argv[i]));</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">                    while (!scanner.zzAtEOF)</span>
                    {
<span class="nc" id="L818">                        scanner.yylex();</span>
                    }
                }
<span class="nc" id="L821">                catch (java.io.FileNotFoundException e)</span>
                {
<span class="nc" id="L823">                    System.out.println(&quot;File not found : \&quot;&quot; + argv[i] + &quot;\&quot;&quot;);</span>
                }
<span class="nc" id="L825">                catch (java.io.IOException e)</span>
                {
<span class="nc" id="L827">                    System.out.println(&quot;IO error scanning file \&quot;&quot; + argv[i] + &quot;\&quot;&quot;);</span>
<span class="nc" id="L828">                    System.out.println(e);</span>
                }
<span class="nc" id="L830">                catch (Exception e)</span>
                {
<span class="nc" id="L832">                    System.out.println(&quot;Unexpected exception:&quot;);</span>
<span class="nc" id="L833">                    e.printStackTrace();</span>
<span class="nc" id="L834">                }</span>
            }
        }
<span class="nc" id="L837">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>