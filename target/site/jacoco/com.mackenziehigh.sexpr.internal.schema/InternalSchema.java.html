<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InternalSchema.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sexpr</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.sexpr.internal.schema</a> &gt; <span class="el_source">InternalSchema.java</span></div><h1>InternalSchema.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2017 Michael Mackenzie High
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.mackenziehigh.sexpr.internal.schema;

import com.mackenziehigh.sexpr.SAtom;
import com.mackenziehigh.sexpr.SList;
import com.mackenziehigh.sexpr.Sexpr;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.SortedMap;
import java.util.Stack;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.function.Consumer;
import java.util.function.Predicate;
import com.mackenziehigh.sexpr.Schema.Match;

/**
 * An instance of this class is a pattern that describes a symbolic-expression.
 */
public final class InternalSchema
{
    /**
     * This counter is used to create names for anonymous rules.
     */
<span class="fc" id="L47">    private static int counter = 1;</span>

    /**
     * This maintains important state during a match attempt.
     */
<span class="fc" id="L52">    private final class MatchState</span>
    {
        /**
         * This stack is used to store match-nodes.
         * Whenever a successful match occurs, it will be placed onto this stack.
         * Matches will be popped of this stack and made the children of other matches.
         */
<span class="fc" id="L59">        private final Stack&lt;Object&gt; matches = new Stack&lt;&gt;();</span>

        /**
         * This was the last node in the symbolic-expression
         * that was successfully matched, if any.
         */
<span class="fc" id="L65">        private Sexpr lastSuccess = null;</span>

        /**
         * This method retrieves the last node in the symbolic-expression
         * that was successfully matched by a rule in the schema,
         * if such a node exists.
         *
         * &lt;p&gt;
         * The last successful node is useful for debugging purposes.
         * &lt;/p&gt;
         *
         * @return the site of the last successful match, if any.
         */
        public Optional&lt;Sexpr&gt; lastSuccess ()
        {
<span class="nc" id="L80">            return Optional.ofNullable(lastSuccess);</span>
        }

        /**
         * This method is invoked whenever a rule begins a match-attempt.
         *
         * @param node is the node that the rule is attempting to match.
         */
        private void enter (final Sexpr node)
        {
<span class="fc" id="L90">            Objects.requireNonNull(node, &quot;node&quot;);</span>
<span class="fc" id="L91">            matches.push(node);</span>
<span class="fc" id="L92">        }</span>

        /**
         * This method is invoked whenever a rule exits a match-attempt
         * due to the fact that the rule successfully matched.
         *
         * @param rule is the rule invoking this method.
         * @param node is the node that was successfully matched.
         * @return the representation of the successful match.
         */
        private InternalMatchNode exitOnSuccess (final Rule rule,
                                         final Sexpr node)
        {
<span class="fc" id="L105">            lastSuccess = node;</span>

            /**
             * Remove any successful child matches from the stack.
             */
<span class="fc" id="L110">            final LinkedList&lt;InternalMatchNode&gt; children = new LinkedList&lt;&gt;();</span>

<span class="fc bfc" id="L112" title="All 2 branches covered.">            while (matches.peek() != node)</span>
            {
<span class="fc" id="L114">                children.addFirst((InternalMatchNode) matches.pop());</span>
            }

            /**
             * Undo push(node) in enter(node).
             */
<span class="fc" id="L120">            matches.pop();</span>

            /**
             * Create the representation of the successful match.
             */
<span class="fc" id="L125">            final InternalMatchNode match = new InternalMatchNode(rule, node, children);</span>
<span class="fc" id="L126">            matches.push(match);</span>

<span class="fc" id="L128">            return match;</span>
        }

        /**
         * This method is invoked whenever a rule exits a match-attempt
         * due to the fact that the rule failed to match the node.
         *
         * @param node is the node that was unsuccessfully matched.
         * @return null always.
         */
        private InternalMatchNode exitOnFailure (final Sexpr node)
        {
            /**
             * Remove any successful child matches from the stack.
             */
<span class="fc bfc" id="L143" title="All 2 branches covered.">            while (matches.peek() != node)</span>
            {
<span class="fc" id="L145">                matches.pop();</span>
            }

            /**
             * Undo push(node) in enter(node).
             */
<span class="fc" id="L151">            matches.pop();</span>

<span class="fc" id="L153">            return null;</span>
        }
    }

    /**
     * An instance of this interface is a constraint on a single node in a symbolic-expression.
     */
<span class="fc" id="L160">    abstract class Rule</span>
    {
        /**
         * The default-name starts with a '#' sign,
         * since '#' starts comments in schemas
         * we can be sure that no rule will (ever)
         * have such a name.
         */
<span class="fc" id="L168">        private final String defaultName = &quot;#&quot; + counter++;</span>

        /**
         * This method determines whether this rule matches the given node.
         *
         * &lt;p&gt;
         * This method must invoke state.enter(node).
         * This method must invoke state.exitOnSuccess(node)
         * or state.exitOnFailure(node) depending on the result.
         * &lt;/p&gt;
         *
         * @param state maintains the state of the overall match attempt.
         * @param node may obey the pattern described by this rule.
         * @return an object representing the successful match of this rule,
         * or null, if this rule does not match the given node.
         */
        public abstract InternalMatchNode match (MatchState state,
                                         Sexpr node);

        /**
         * This method retrieves the name of this rule.
         *
         * @return the name of this rule.
         */
        public String name ()
        {
<span class="fc" id="L194">            return defaultName;</span>
        }
    }

    /**
     * An instance of this interface represents a single element in a sequence-rule.
     */
    interface SequenceElement
    {
        /**
         * This method retrieves the name of the rule that describes the sequence element.
         *
         * @return the name of a rule in the schema.
         */
        public String element ();

        /**
         * This method retrieves the minimum number of times that the element must repeat.
         *
         * @return the lower bound of the sequence-element.
         */
        public int minimum ();

        /**
         * This method retrieves the maximum number of times that the element must repeat.
         *
         * @return the upper bound of the sequence-element.
         */
        public int maximum ();
    }

    /**
     * These are all of the rules that are defined within the schema.
     */
<span class="fc" id="L228">    private final SortedMap&lt;String, Rule&gt; rules = new TreeMap&lt;&gt;();</span>

    /**
     * This supplier supplies the name of the root rule of the schema.
     */
<span class="fc" id="L233">    private String root = &quot;root&quot;;</span>

    /**
     * This map maps the names of user-defined conditions
     * to the definitions of those conditions, if any.
     */
<span class="fc" id="L239">    private final Map&lt;String, Predicate&lt;Sexpr&gt;&gt; conditions = new TreeMap&lt;&gt;();</span>

    /**
     * These are the names of the user-defined translation passes.
     */
<span class="fc" id="L244">    private final List&lt;String&gt; passes = new LinkedList&lt;&gt;();</span>

    /**
     * This map maps the name of a translation pass (P) to a map that maps the name
     * of a rule (R) in the schema to a list of user-defined actions (A1 ... AN)
     * that will be performed for each successful match of (R) during pass (P).
     */
<span class="fc" id="L251">    private final Map&lt;String, Map&lt;String, List&lt;Consumer&lt;Sexpr&gt;&gt;&gt;&gt; beforeActions = new TreeMap&lt;&gt;();</span>

    /**
     * This map maps the name of a translation pass (P) to a map that maps the name
     * of a rule (R) in the schema to a list of user-defined actions (A1 ... AN)
     * that will be performed for each successful match of (R) during pass (P).
     */
<span class="fc" id="L258">    private final Map&lt;String, Map&lt;String, List&lt;Consumer&lt;Sexpr&gt;&gt;&gt;&gt; afterActions = new TreeMap&lt;&gt;();</span>

    /**
     * These are the names of all of the rules that have been used in the schema.
     * This may include undefined rules due to typos, etc, made by the user.
     * Such problems need to be detected and reported.
     */
<span class="fc" id="L265">    private final Set&lt;String&gt; usedRules = new TreeSet&lt;&gt;();</span>

    /**
     * Sole Constructor.
     */
    public InternalSchema ()
<span class="fc" id="L271">    {</span>
        /**
         * Define the predefined rules, whose names always start with a '$' by convention.
         */
<span class="pc" id="L275">        rules.put(&quot;$ANY&quot;, defineRuleByPredicate(x -&gt; true));</span>
<span class="pc bpc" id="L276" title="1 of 4 branches missed.">        rules.put(&quot;$BOOLEAN&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.asAtom().asBoolean().isPresent()));</span>
<span class="pc bnc" id="L277" title="All 4 branches missed.">        rules.put(&quot;$CHAR&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.asAtom().asChar().isPresent()));</span>
<span class="pc bpc" id="L278" title="1 of 4 branches missed.">        rules.put(&quot;$BYTE&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.asAtom().asByte().isPresent()));</span>
<span class="pc bpc" id="L279" title="1 of 4 branches missed.">        rules.put(&quot;$SHORT&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.asAtom().asShort().isPresent()));</span>
<span class="pc bpc" id="L280" title="1 of 4 branches missed.">        rules.put(&quot;$INT&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.asAtom().asInt().isPresent()));</span>
<span class="pc bpc" id="L281" title="1 of 4 branches missed.">        rules.put(&quot;$LONG&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.asAtom().asLong().isPresent()));</span>
<span class="pc bnc" id="L282" title="All 4 branches missed.">        rules.put(&quot;$FLOAT&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.asAtom().asFloat().isPresent()));</span>
<span class="pc bnc" id="L283" title="All 4 branches missed.">        rules.put(&quot;$DOUBLE&quot;, defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.asAtom().asDouble().isPresent()));</span>
<span class="pc" id="L284">        rules.put(&quot;$ATOM&quot;, defineRuleByPredicate(x -&gt; x.isAtom()));</span>
<span class="pc" id="L285">        rules.put(&quot;$LIST&quot;, defineRuleByPredicate(x -&gt; x.isList()));</span>
<span class="fc" id="L286">    }</span>

    /**
     * This method causes a rule to be added to this schema.
     *
     * @param rule is the rule to add.
     * @return the rule.
     */
    private Rule define (final Rule rule)
    {
<span class="fc" id="L296">        Objects.requireNonNull(rule, &quot;rule&quot;);</span>
<span class="fc" id="L297">        rules.put(rule.name(), rule);</span>
<span class="fc" id="L298">        return rule;</span>
    }

    /**
     * Use this method to specify the root rule of this schema.
     *
     * @param root is the name of the root rule.
     */
    public void defineRoot (final String root)
    {
<span class="fc" id="L308">        Objects.requireNonNull(root, &quot;root&quot;);</span>
<span class="fc" id="L309">        usedRules.add(root);</span>
<span class="fc" id="L310">        this.root = root;</span>
<span class="fc" id="L311">    }</span>

    /**
     * This method defines a condition that can be referenced by a 'require' rule.
     *
     * @param name is the name of the user-defined condition.
     * @param condition is the user-defined condition itself.
     */
    public void defineCondition (final String name,
                                 final Predicate&lt;Sexpr&gt; condition)
    {
<span class="fc" id="L322">        Objects.requireNonNull(name, &quot;name&quot;);</span>
<span class="fc" id="L323">        Objects.requireNonNull(condition, &quot;condition&quot;);</span>
<span class="fc" id="L324">        conditions.put(name, condition);</span>
<span class="fc" id="L325">    }</span>

    public void definePass (final String name)
    {
<span class="fc" id="L329">        passes.add(name);</span>
<span class="fc" id="L330">    }</span>

    public void defineBeforeAction (final String pass,
                                    final String rule,
                                    final Consumer&lt;Sexpr&gt; action)
    {
<span class="fc bfc" id="L336" title="All 2 branches covered.">        if (beforeActions.containsKey(pass) == false)</span>
        {
<span class="fc" id="L338">            beforeActions.put(pass, new TreeMap&lt;&gt;());</span>
        }

<span class="pc bpc" id="L341" title="1 of 2 branches missed.">        if (beforeActions.get(pass).containsKey(rule) == false)</span>
        {
<span class="fc" id="L343">            beforeActions.get(pass).put(rule, new LinkedList&lt;&gt;());</span>
        }

<span class="fc" id="L346">        beforeActions.get(pass).get(rule).add(action);</span>
<span class="fc" id="L347">    }</span>

    public void defineAfterAction (final String pass,
                                   final String rule,
                                   final Consumer&lt;Sexpr&gt; action)
    {

<span class="fc bfc" id="L354" title="All 2 branches covered.">        if (afterActions.containsKey(pass) == false)</span>
        {
<span class="fc" id="L356">            afterActions.put(pass, new TreeMap&lt;&gt;());</span>
        }

<span class="pc bpc" id="L359" title="1 of 2 branches missed.">        if (afterActions.get(pass).containsKey(rule) == false)</span>
        {
<span class="fc" id="L361">            afterActions.get(pass).put(rule, new LinkedList&lt;&gt;());</span>
        }

<span class="fc" id="L364">        afterActions.get(pass).get(rule).add(action);</span>

<span class="fc" id="L366">    }</span>

    /**
     * Use this method to create a rule that provides a name for another rule.
     *
     * @param name is the name of the new rule.
     * @param body is the name of the referenced (usually anonymous) rule.
     * @return the new rule.
     */
    final Rule defineNamedRule (final String name,
                                final String body)
    {
<span class="fc" id="L378">        Objects.requireNonNull(name, &quot;name&quot;);</span>
<span class="fc" id="L379">        Objects.requireNonNull(body, &quot;body&quot;);</span>

<span class="fc bfc" id="L381" title="All 2 branches covered.">        if (rules.containsKey(name))</span>
        {
<span class="fc" id="L383">            throw new IllegalStateException(&quot;Duplicate Rule: &quot; + name);</span>
        }

<span class="fc" id="L386">        usedRules.add(name);</span>
<span class="fc" id="L387">        usedRules.add(body);</span>

<span class="fc" id="L389">        final Rule rule = new Rule()</span>
<span class="fc" id="L390">        {</span>
            @Override
            public String name ()
            {
<span class="fc" id="L394">                return name;</span>
            }

            @Override
            public InternalMatchNode match (final MatchState state,
                                    final Sexpr node)
            {
<span class="fc" id="L401">                state.enter(node);</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">                final boolean answer = rules.get(body).match(state, node) != null;</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">                return answer ? state.exitOnSuccess(this, node) : state.exitOnFailure(node);</span>
            }
        };

<span class="fc" id="L407">        return define(rule);</span>
    }

    /**
     * Use this method to create a rule that is a lazy reference to another rule.
     *
     * @param name is the name of the new rule.
     * @return the new rule.
     */
    final Rule defineReference (final String name)
    {
<span class="fc" id="L418">        Objects.requireNonNull(name, &quot;name&quot;);</span>

<span class="fc" id="L420">        usedRules.add(name);</span>

        /**
         * This type of rule is a special-case.
         * Do *not* invoke enter(*), exitOnSuccess(*), or exitOnFailure(*),
         * because that would break how action execution works.
         */
<span class="fc" id="L427">        final Rule rule = new Rule()</span>
<span class="fc" id="L428">        {</span>
            @Override
            public InternalMatchNode match (final MatchState state,
                                    final Sexpr node)
            {
<span class="fc" id="L433">                return rules.get(name).match(state, node);</span>
            }
        };

<span class="fc" id="L437">        return define(rule);</span>
    }

    /**
     * Use this method to define a rule that will only successfully match
     * a node when a series of operand rules always match the node.
     *
     * @param operands must all match the same node in order for the new rule to match.
     * @return the new rule.
     */
    final Rule defineAndRule (final List&lt;String&gt; operands)
    {
<span class="fc" id="L449">        Objects.requireNonNull(operands, &quot;operands&quot;);</span>
<span class="fc" id="L450">        operands.forEach(operand -&gt; Objects.requireNonNull(operand, &quot;operand&quot;));</span>

<span class="fc" id="L452">        usedRules.addAll(operands);</span>

<span class="fc" id="L454">        final Rule rule = new Rule()</span>
<span class="fc" id="L455">        {</span>
            @Override
            public InternalMatchNode match (final MatchState state,
                                    final Sexpr node)
            {
<span class="fc" id="L460">                state.enter(node);</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">                final boolean answer = operands.stream().map(name -&gt; rules.get(name)).allMatch(rule -&gt; rule.match(state, node) != null);</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">                return answer ? state.exitOnSuccess(this, node) : state.exitOnFailure(node);</span>
            }
        };

<span class="fc" id="L466">        return define(rule);</span>
    }

    /**
     * Use this method to define a rule that will successfully match a node
     * when the first of a series of operand rules matches the node.
     *
     * @param operands are the options that may match the node.
     * @return the new rule.
     */
    final Rule defineOrRule (final List&lt;String&gt; operands)
    {
<span class="fc" id="L478">        Objects.requireNonNull(operands, &quot;operands&quot;);</span>
<span class="fc" id="L479">        operands.forEach(operand -&gt; Objects.requireNonNull(operand, &quot;operand&quot;));</span>

<span class="fc" id="L481">        usedRules.addAll(operands);</span>

<span class="fc" id="L483">        final Rule rule = new Rule()</span>
<span class="fc" id="L484">        {</span>
            @Override
            public InternalMatchNode match (final MatchState state,
                                    final Sexpr node)
            {
<span class="fc" id="L489">                state.enter(node);</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">                final boolean answer = operands.stream().map(name -&gt; rules.get(name)).anyMatch(rule -&gt; rule.match(state, node) != null);</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">                return answer ? state.exitOnSuccess(this, node) : state.exitOnFailure(node);</span>
            }
        };

<span class="fc" id="L495">        return define(rule);</span>
    }

    /**
     * Use this method to define a rule that will only successfully
     * match a node when a given operand rule fails to match.
     *
     * @param operand the rule that is negated by the new rule.
     * @return the new rule.
     */
    final Rule defineNotRule (final String operand)
    {
<span class="fc" id="L507">        Objects.requireNonNull(operand, &quot;operand&quot;);</span>

<span class="fc" id="L509">        usedRules.add(operand);</span>

<span class="fc" id="L511">        final Rule rule = new Rule()</span>
<span class="fc" id="L512">        {</span>
            @Override
            public InternalMatchNode match (final MatchState state,
                                    final Sexpr node)
            {
<span class="fc" id="L517">                state.enter(node);</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">                final boolean answer = rules.get(operand).match(state, node) == null;</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">                return answer ? state.exitOnSuccess(this, node) : state.exitOnFailure(node);</span>
            }
        };

<span class="fc" id="L523">        return define(rule);</span>
    }

    /**
     * Use this method to define a rule that will only successfully
     * match a symbolic-list that obeys a proscribed sequence.
     *
     * @param operands describe the elements in the sequence.
     * @return the new rule.
     */
    final Rule defineSequenceRule (final List&lt;? extends SequenceElement&gt; operands)
    {
<span class="fc" id="L535">        Objects.requireNonNull(operands, &quot;operands&quot;);</span>
<span class="fc" id="L536">        operands.forEach(operand -&gt; Objects.requireNonNull(operand, &quot;operand&quot;));</span>

<span class="fc bfc" id="L538" title="All 2 branches covered.">        for (SequenceElement operand : operands)</span>
        {
<span class="fc bfc" id="L540" title="All 2 branches covered.">            if (operand.maximum() &lt; operand.minimum())</span>
            {
<span class="fc" id="L542">                final String message = String.format(&quot;Invalid Range: { %d, %d }&quot;,</span>
<span class="fc" id="L543">                                                     operand.minimum(),</span>
<span class="fc" id="L544">                                                     operand.maximum());</span>
<span class="fc" id="L545">                throw new IllegalStateException(message);</span>
            }
<span class="fc" id="L547">        }</span>

<span class="fc" id="L549">        operands.forEach(x -&gt; usedRules.add(x.element()));</span>

<span class="fc" id="L551">        final Rule rule = new Rule()</span>
<span class="fc" id="L552">        {</span>
            @Override
            public InternalMatchNode match (final MatchState state,
                                    final Sexpr node)
            {
<span class="fc" id="L557">                return sequenceMatch(this, operands, state, node);</span>
            }
        };

<span class="fc" id="L561">        return define(rule);</span>
    }

    private InternalMatchNode sequenceMatch (final Rule rule,
                                     final List&lt;? extends SequenceElement&gt; operands,
                                     final MatchState state,
                                     final Sexpr node)
    {
<span class="fc" id="L569">        Objects.requireNonNull(rule, &quot;rule&quot;);</span>
<span class="fc" id="L570">        Objects.requireNonNull(operands, &quot;operands&quot;);</span>
<span class="fc" id="L571">        operands.forEach(operand -&gt; Objects.requireNonNull(operand, &quot;operand&quot;));</span>
<span class="fc" id="L572">        Objects.requireNonNull(state, &quot;state&quot;);</span>
<span class="fc" id="L573">        Objects.requireNonNull(node, &quot;node&quot;);</span>

<span class="fc" id="L575">        state.enter(node);</span>

<span class="pc bpc" id="L577" title="1 of 2 branches missed.">        if (node.isList() == false)</span>
        {
<span class="nc" id="L579">            return state.exitOnFailure(node);</span>
        }

<span class="fc" id="L582">        final Deque&lt;Sexpr&gt; nodes = new ArrayDeque&lt;&gt;(node.asList());</span>

<span class="fc bfc" id="L584" title="All 2 branches covered.">seq:    for (SequenceElement operand : operands)</span>
        {
            int i;

            /**
             * The operand rule must match at least the minimum number of times.
             */
<span class="fc bfc" id="L591" title="All 2 branches covered.">            for (i = 0; i &lt; operand.minimum(); i++)</span>
            {
                /**
                 * If no more nodes are in the list, then the rule has failed to match,
                 * because the minium match count was not reached for this operand rule.
                 */
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">                if (nodes.isEmpty())</span>
                {
<span class="nc" id="L599">                    return state.exitOnFailure(node);</span>
                }

<span class="fc" id="L602">                final Sexpr next = nodes.peek();</span>
<span class="fc" id="L603">                final InternalMatchNode match = rules.get(operand.element()).match(state, next);</span>

<span class="fc bfc" id="L605" title="All 2 branches covered.">                if (match == null)</span>
                {
<span class="fc" id="L607">                    return state.exitOnFailure(node);</span>
                }
                else
                {
<span class="fc" id="L611">                    nodes.pop();</span>
                }
            }

            /**
             * The operand rule can continue to match until the maximum is reached.
             */
<span class="fc bfc" id="L618" title="All 2 branches covered.">            for (i = i + 0; i &lt; operand.maximum(); i++)</span>
            {
                /**
                 * If no more nodes are in the list, then goto the next operand rule,
                 * because the tail rules may be require to match more than zero times.
                 * In that case, the overall sequence rule has failed,
                 * even though the current operand rule succeeded.
                 */
<span class="fc bfc" id="L626" title="All 2 branches covered.">                if (nodes.isEmpty())</span>
                {
<span class="fc" id="L628">                    continue seq;</span>
                }

<span class="fc" id="L631">                final Sexpr next = nodes.peek();</span>
<span class="fc" id="L632">                final InternalMatchNode match = rules.get(operand.element()).match(state, next);</span>

<span class="fc bfc" id="L634" title="All 2 branches covered.">                if (match == null)</span>
                {
<span class="fc" id="L636">                    continue seq; // Go to the next operand rule.</span>
                }
                else
                {
<span class="fc" id="L640">                    nodes.pop();</span>
                }
            }
<span class="fc" id="L643">        }</span>

        /**
         * If there are still more nodes in the list,
         * then the sequence-rule only described the prefix of the list,
         * which we do not consider to be a true match of the list.
         */
<span class="fc bfc" id="L650" title="All 2 branches covered.">        if (nodes.isEmpty() == false)</span>
        {
<span class="fc" id="L652">            return state.exitOnFailure(node);</span>
        }

<span class="fc" id="L655">        return state.exitOnSuccess(rule, node);</span>
    }

    /**
     * Use this method to define a rule that will only successfully match
     * a symbolic-atom whose content() matches a given regular-expression.
     *
     * @param pattern is the given symbolic-expression.
     * @return the new rule.
     */
    final Rule defineRegexRule (final String pattern)
    {
<span class="fc" id="L667">        Objects.requireNonNull(pattern, &quot;pattern&quot;);</span>

<span class="pc bpc" id="L669" title="1 of 4 branches missed.">        return defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.asAtom().content().matches(pattern));</span>
    }

    /**
     * Use this method to define a rule that will only successfully
     * match a symbolic-atom whose content() equals the given value.
     *
     * @param value is the value that must be the content() of the node.
     * @return the new rule.
     */
    final Rule defineConstantRule (final String value)
    {
<span class="fc" id="L681">        Objects.requireNonNull(value, &quot;value&quot;);</span>

<span class="pc bpc" id="L683" title="2 of 4 branches missed.">        return defineRuleByPredicate(x -&gt; x.isAtom() &amp;&amp; x.asAtom().content().equals(value));</span>
    }

    /**
     * Use this method to define a new rule that will only successfully
     * match a node when a user-defined predicate matches the node.
     *
     * @param name is the name of the user-defined requirement.
     * @return the new rule.
     */
    final Rule definePredicateRule (final String name)
    {
<span class="fc" id="L695">        Objects.requireNonNull(name, &quot;name&quot;);</span>

<span class="fc" id="L697">        return defineRuleByPredicate(x -&gt; Optional.ofNullable(conditions.get(name)).get().test(x));</span>
    }

    /**
     * Use this method to define a new rule that will only successfully
     * match a node when a given predicate matches the node.
     *
     * @param condition is the predicate.
     * @return the new rule.
     */
    private Rule defineRuleByPredicate (final Predicate&lt;Sexpr&gt; condition)
    {
<span class="fc" id="L709">        Objects.requireNonNull(condition, &quot;condition&quot;);</span>

<span class="fc" id="L711">        final Rule rule = new Rule()</span>
<span class="fc" id="L712">        {</span>
            @Override
            public InternalMatchNode match (final MatchState state,
                                    final Sexpr node)
            {
<span class="fc" id="L717">                state.enter(node);</span>
<span class="fc" id="L718">                final boolean answer = condition.test(node);</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">                return answer ? state.exitOnSuccess(this, node) : state.exitOnFailure(node);</span>
            }
        };

<span class="fc" id="L723">        return define(rule);</span>
    }

    /**
     * This method performs a match-attempt.
     *
     * @param tree is the symbolic-expression that this schema may match.
     * @return an object describing the result.
     */
    public Match match (final Sexpr tree)
    {
<span class="fc" id="L734">        Objects.requireNonNull(tree, &quot;tree&quot;);</span>

        /**
         * Verify that this schema is well-defined.
         */
<span class="fc" id="L739">        validate();</span>

        /**
         * Perform the match attempt.
         */
<span class="fc" id="L744">        final MatchState state = new MatchState();</span>
<span class="fc" id="L745">        final Rule rootRule = rules.get(root);</span>
<span class="fc" id="L746">        final InternalMatchNode match = rootRule.match(state, tree);</span>

        /**
         * If the match-attempt failed, then report the failure;
         * otherwise, execute the user-defined passes and actions.
         */
<span class="fc bfc" id="L752" title="All 2 branches covered.">        final boolean success = match != null;</span>
<span class="fc" id="L753">        final Match result = new InternalMatch(success,</span>
                                                           match,
                                                           state.lastSuccess,
<span class="fc" id="L756">                                                           List.copyOf(passes),</span>
<span class="fc" id="L757">                                                           Map.copyOf(beforeActions),</span>
<span class="fc" id="L758">                                                           Map.copyOf(afterActions));</span>
<span class="fc" id="L759">        return result;</span>
    }

    public void validate ()
    {
<span class="fc" id="L764">        requireRoot();</span>
<span class="fc" id="L765">        checkForUndefinedRules();</span>
<span class="fc" id="L766">        checkForUndeclaredPasses();</span>
<span class="fc" id="L767">    }</span>

    private void requireRoot ()
    {
<span class="pc bpc" id="L771" title="1 of 2 branches missed.">        if (rules.containsKey(root) == false)</span>
        {
<span class="nc" id="L773">            throw new IllegalStateException(&quot;No Root Rule&quot;);</span>
        }
<span class="fc" id="L775">    }</span>

    /**
     * This method reports any rules that are used, but not defined in the schema.
     */
    private void checkForUndefinedRules ()
    {
<span class="fc" id="L782">        final Set&lt;String&gt; definedRules = rules.keySet();</span>
<span class="fc" id="L783">        final Set&lt;String&gt; temp = new HashSet&lt;&gt;(usedRules);</span>
<span class="fc" id="L784">        temp.removeAll(definedRules);</span>
<span class="fc" id="L785">        final List&lt;String&gt; undefinedRules = new ArrayList&lt;&gt;(temp);</span>

<span class="pc bpc" id="L787" title="1 of 2 branches missed.">        if (undefinedRules.isEmpty() == false)</span>
        {
<span class="nc" id="L789">            final String names = SList.copyOf(undefinedRules.stream().map(name -&gt; SAtom.fromString(name))).toString();</span>
<span class="nc" id="L790">            final String message = &quot;Undefined Rules Detected: &quot; + names;</span>
<span class="nc" id="L791">            throw new IllegalStateException(message);</span>
        }
<span class="fc" id="L793">    }</span>

    private void checkForUndeclaredPasses ()
    {
        /**
         * Check for before-actions that are not apart of a declared pass.
         */
<span class="fc bfc" id="L800" title="All 2 branches covered.">        for (String pass : beforeActions.keySet())</span>
        {
<span class="fc bfc" id="L802" title="All 2 branches covered.">            if (passes.contains(pass) == false)</span>
            {
<span class="fc" id="L804">                throw new IllegalStateException(String.format(&quot;Undeclared Pass: %s&quot;, pass));</span>
            }
<span class="fc" id="L806">        }</span>

        /**
         * Check for after-actions that are not apart of a declared pass.
         */
<span class="fc bfc" id="L811" title="All 2 branches covered.">        for (String pass : afterActions.keySet())</span>
        {
<span class="fc bfc" id="L813" title="All 2 branches covered.">            if (passes.contains(pass) == false)</span>
            {
<span class="fc" id="L815">                throw new IllegalStateException(String.format(&quot;Undeclared Pass: %s&quot;, pass));</span>
            }
<span class="fc" id="L817">        }</span>
<span class="fc" id="L818">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>